<!DOCTYPE html>
<html lang="pt-BR" class="scroll-smooth">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WRPG</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&display=swap"
        rel="stylesheet">

    <style type="text/tailwindcss">
        .attribute-mode-btn.active {
    @apply bg-[#543C32] ring-2 ring-[#A1887F]; /* Cor ligeiramente mais escura e anel para indicar que está ativo */
}
        /* Adicionar ao seu CSS existente */
    #character-setup-screen.hidden {
        display: none;
    }

    /* --- THEME: DARK BROWN --- */
    body {
        /* background-image: url('https://www.transparenttextures.com/patterns/dark-leather.png'); */ /* Optional: Subtle dark texture */
        background-color: #3B2E26; /* Deep Dark Brown */
        font-family: 'Merriweather', serif;
        color: #D7CCC8; /* Light Beige/Brownish Gray text */
        transition: background-image 0.7s ease-in-out;
    }

    /* Dynamic Background Classes */
    .bg-theme-default {
        /* background-image: url('https://www.transparenttextures.com/patterns/dark-leather.png') !important; */
        background-color: #3B2E26 !important; /* Deep Dark Brown */
    }
    .bg-theme-forest {
        background-image: url('https://source.unsplash.com/random/1920x1080/?dark,fantasy,forest,night') !important; /* Added night for darker feel */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
    .bg-theme-battle {
        background-image: url('https://source.unsplash.com/random/1920x1080/?battlefield,fantasy,medieval,gloomy') !important; /* Added gloomy */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
    .bg-theme-dungeon {
        background-image: url('https://source.unsplash.com/random/1920x1080/?dungeon,dark,stone,corridor,shadows') !important; /* Added shadows */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }
    .bg-theme-boss-hall {
        background-image: url('https://source.unsplash.com/random/1920x1080/?throne,room,boss,hall,fantasy,epic,dark') !important; /* Added dark */
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }

    /* Header Styling */
    header.bg-slate-900 { /* Was: #5D4037 (Old Book) */
        @apply bg-[#2A1F1B] border-b-2 border-[#1F1611]; /* Very Dark Brown, like a tome cover */
    }
    header h1 { /* Was: #E0C097 */
        @apply text-[#E0C097]; /* Parchment text for title - still good */
    }
    header nav button, header nav button i { /* Was: #E0C097 hover:#FDF5E6 */
        @apply text-[#D7CCC8] hover:text-[#FFF8E1]; /* Light Beige text, lighter hover (Cornsilk) */
        font-family: 'Merriweather', serif;
    }
    header nav button#btn-save-google, header nav button#btn-save-google i { /* Was: #B08D57 hover:#A1887F */
        @apply text-[#FFCA28] hover:text-[#FFB300]; /* Gold for save, brighter hover */
    }
    header nav button#btn-signout-google, header nav button#btn-signout-google i,
    header nav button#btn-sair, header nav button#btn-sair i { /* Was: #A1887F hover:#8D6E63 */
        @apply text-[#BCAAA4] hover:text-[#A1887F]; /* Muted lighter brown for exit/signout */
    }
    #google-user-greeting { /* Was: #E0C097 */
        @apply text-[#D7CCC8]; /* Match nav button text */
    }

    /* Main Content Area */
    #main-content {
        /* background-color: transparent; */
    }

    /* Game Screen Elements (Containers like story box, stat boxes) */
    #story-text, .bg-slate-700, .bg-slate-800, .bg-slate-600 {
        background-color: rgba(60, 45, 38, 0.6); /* Darker Semi-transparent Brown #3C2D26 base */
        border: 1px solid rgba(83, 64, 55, 0.5); /* #534037 base border */
        @apply shadow-md;
    }
    #story-text {
        background-color: rgba(74, 59, 50, 0.65); /* Slightly more opaque/distinct for story text readability #4A3B32 base */
        border: 1px solid #6D4C41; /* Wood Brown border */
        @apply text-lg leading-relaxed select-text text-[#E0C097]; /* Light Parchment text */
    }

    /* Buttons - General Styling */
    #choices button,
    #battle-main-commands button,
    #btn-salvar-atributos,
    #btn-comprar-mercador {
        @apply bg-[#6D4C41] hover:bg-[#543C32] text-[#FFF8E1] border border-[#4E342E] shadow-sm; /* Wood Brown bg, Cornsilk text */
        @apply focus:ring-[#A1887F] focus:ring-offset-2 focus:ring-offset-[#3B2E26]; /* Muted brown ring, dark offset */
        font-family: 'Merriweather', serif;
    }
    #choices button:disabled,
    #battle-main-commands button:disabled,
    #btn-comprar-mercador:disabled {
        @apply bg-[#5A4A44] text-[#887972] border-[#4A3A34] cursor-default; /* Muted dark background, muted lighter text for disabled */
        font-family: 'Merriweather', serif;
    }

    /* Atributos Screen */
    .atributos-fundo {
        /* background-image: url('https://www.transparenttextures.com/patterns/dark-wood.png'); */ /* Optional: Dark wood texture */
        background-color: #31251E; /* Very Dark Brown for this screen's base */
        border: 2px solid #1F1611; /* Even darker border */
        padding: 1rem;
    }
    #atributos-screen h2, #atributos-screen h4 {
        @apply text-[#E0C097]; /* Light Parchment for titles */
    }
    #atributos-screen .bg-slate-700, #atributos-screen .bg-slate-600 { /* For containers within attributes */
        background-color: rgba(93, 64, 55, 0.4); /* #5D4037 base, semi-transparent */
        border: 1px solid #4E342E; /* Darker brown border */
    }
    #status-nivel, #status-rank, #status-classe, #status-moedas,
    #bonus-dano-fisico, #bonus-dano-magico, #bonus-resistencia span, #bonus-fuga span, #bonus-esquiva span,
    #forca-val, #agilidade-val, #inteligencia-val, #resistencia-val, #vitalidade-val, #percepcao-val,
    #pontos-disponiveis {
        @apply text-[#D7CCC8]; /* Light Beige for general values */
    }
    #status-nivel { @apply text-[#A5D6A7]; } /* Light Green */
    #status-rank { @apply text-[#FFCA28]; } /* Amber/Gold */
    #status-classe { @apply text-[#BCAAA4]; } /* Muted Light Brown */
    #status-moedas { @apply text-[#FFCA28]; } /* Amber/Gold */

    #atributos-screen .text-slate-400 { /* Small labels */
        @apply text-[#A1887F]; /* Muted Brown (lighter than dark bg) */
    }
    #atributos-screen .text-purple-300 { @apply text-[#CE93D8]; } /* Light Purple for XP Label */
    #atributos-screen .text-red-400 { @apply text-[#EF9A9A]; } /* Light Red for Vida Label */
    #atributos-screen .text-blue-400 { @apply text-[#90CAF9]; } /* Light Blue for Mana Label */

    #bonus-dano-fisico { @apply text-[#FFAB91]; } /* Light Orange/Peach for physical damage */
    #bonus-dano-magico { @apply text-[#81D4FA]; } /* Light Cyan for magical damage */
    #bonus-resistencia span { @apply text-[#A5D6A7]; } /* Light green for reduction value */
    #bonus-esquiva span, #bonus-fuga span { @apply text-[#BCAAA4]; } /* Muted light brown for evasion/escape */

    #forca-rank, #agilidade-rank, #inteligencia-rank, #resistencia-rank, #vitalidade-rank, #percepcao-rank {
        @apply text-[#FFCA28]; /* Amber/Gold for attribute ranks */
    }
    #pontos-disponiveis { @apply text-[#FFCA28]; }

    #status-xp-bar, #status-vida-bar, #status-mana-bar {
        border: 1px solid #543C32; /* Darker Wood brown border for bars */
    }
    /* Attribute Modification Buttons */
    #atributos-screen .btn-attr {
        font-family: 'Merriweather', serif;
        @apply text-[#FFF8E1] transition-colors px-3 py-1 rounded-md focus:outline-none focus:ring-2;
    }
    #atributos-screen button[data-action="dec"].btn-attr { /* Was: #A1887F hover:#8D6E63 */
        @apply bg-[#8D6E63] hover:bg-[#6D4C41] focus:ring-[#795548]; /* Darker Muted Brown */
    }
    #atributos-screen button[data-action="inc"].btn-attr { /* Was: #795548 hover:#5D4037 */
        @apply bg-[#6D4C41] hover:bg-[#543C32] focus:ring-[#6D4C41]; /* Wood Brown */
    }

    /* BAR COLORS - Keep vibrant for visibility or choose desaturated versions */
    #status-xp-bar { @apply bg-[#9C27B0]; }   /* Purple (deeper) */
    #status-vida-bar { @apply bg-[#D32F2F]; } /* Red (deeper) */
    #status-mana-bar { @apply bg-[#1976D2]; } /* Blue (deeper) */

    /* Battle Screen Progress Bars */
    #player-battle-hp-bar { @apply bg-[#D32F2F]; }
    #player-battle-mp-bar { @apply bg-[#1976D2]; }
    #player-battle-xp-bar { @apply bg-[#9C27B0]; }
    #summon-battle-hp-bar { @apply bg-[#795548]; } /* Wood brown for summon HP */
    #enemy-battle-hp-bar { @apply bg-[#E64A19]; } /* Deep Orange for enemy HP */

    /* Battle Screen Text (HP/MP/XP values, names) */
    #player-battle-name, #summon-battle-name { @apply text-[#FFCA28]; } /* Amber/Gold */
    #enemy-battle-name { @apply text-[#FF8A65]; } /* Light Deep Orange for enemy name */

    #player-battle-hp-text, #player-battle-mp-text, #player-battle-xp-text,
    #summon-battle-hp-text,
    #enemy-battle-hp-text,
    #enemy-battle-rank {
        @apply text-[#E0C097]; /* Light Parchment text on the battle display cards */
    }
    /* Specifically for labels like "HP", "MP", "XP" next to bars in battle */
    #player-battle-display .text-xs.text-slate-300,
    #summon-battle-display .text-xs.text-slate-300,
    #enemy-battle-display .text-xs.text-slate-300 {
        @apply text-[#BCAAA4]; /* Muted Light Brown for these small labels */
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }
    ::-webkit-scrollbar-track {
        background: #2A1F1B; /* Very Dark Brown track */
    }
    ::-webkit-scrollbar-thumb {
        background: #6D4C41; /* Wood Brown thumb */
        border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
        background: #543C32; /* Darker Wood Brown thumb hover */
    }

    #lista-sombras-recipiente li { margin-bottom: 8px; }

    .equipment-slot-label {
        @apply font-semibold text-sm text-[#BCAAA4] block mb-1; /* Muted Light Brown */
    }
    .equipment-slot-display {
        @apply text-xs text-[#D7CCC8] italic bg-[rgba(93,64,55,0.4)] p-2 rounded min-h-[38px] flex items-center justify-center text-center border border-[#4E342E]; /* Light Beige text, Dark Brown border */
    }
    /* .equipment-grid styles remain the same (layout) */
    .character-placeholder-container i {
        @apply text-[#A1887F]; /* Muted Brown (original, fine for placeholder on dark) */
    }

    /* Skills Screen Enhancement */
    #skills-screen h2 { @apply text-[#E0C097] border-b-2 border-[#6D4C41] pb-2; } /* Light Parchment title, Wood Brown border */
    #classe-info-skills { @apply mb-4 text-lg text-[#D7CCC8]; } /* Light Beige */
    #classe-info-skills p:first-child { @apply font-bold text-[#E0C097]; }
    #lista-skills {
        background-color: rgba(60, 45, 38, 0.3); /* Dark Brown transparent */
        border: 1px solid #786054; /* Muted Dark Gold/Brown border */
        @apply rounded-lg p-4 max-h-[450px] overflow-y-auto space-y-4;
    }
    #lista-skills > div {
        background-color: rgba(83, 60, 47, 0.6) !important; /* Darker Semi-transparent Brown */
        border: 1px solid #6D4C41; /* Wood Brown border */
        @apply rounded-md p-4 shadow;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    #lista-skills > div.opacity-60 { /* For locked skills */
        background-color: rgba(74, 59, 50, 0.5) !important; /* Slightly different Darker semi-transparent */
        border-color: #543C32;
    }
    #lista-skills .skill-title {
        @apply font-bold text-lg text-[#FFCA28]; /* Amber/Gold */
    }
    #lista-skills .skill-description {
        @apply text-sm text-[#D7CCC8] mt-1 mb-1 leading-relaxed; /* Light Beige text */
    }
    #lista-skills .skill-meta {
        @apply text-xs text-[#BCAAA4] italic mt-1; /* Muted Light Brown */
    }
    #lista-skills .skill-actions button {
        @apply bg-[#8D6E63] hover:bg-[#6D4C41] text-[#FFF8E1] text-xs px-3 py-1.5 rounded; /* Dark Muted Brown, Cornsilk text */
        font-family: 'Merriweather', serif;
    }
    #skills-screen p.italic { @apply text-[#BCAAA4]; } /* Muted Light Brown for general note */

    /* Inventario Screen */
    #inventario-screen h2, #inventario-screen h3 { @apply text-[#E0C097] border-b-2 border-[#6D4C41] pb-1; }
    #inventario-screen .bg-slate-700 { /* Container for items/equipment */
        background-color: rgba(93, 64, 55, 0.4); /* #5D4037 base, semi-transparent */
        border: 1px solid #4E342E;
    }
    #lista-itens li, #lista-sombras-recipiente li {
        background-color: rgba(83, 60, 47, 0.5) !important; /* Darker semi-transparent Brown */
        border: 1px solid #786054; /* Muted Dark Gold/Brown border */
    }
    #lista-itens .font-semibold, #lista-sombras-recipiente .text-purple-300 { /* Item/Shadow names */
        @apply text-[#FFCA28]; /* Amber/Gold for item names */
    }
    #lista-sombras-recipiente .text-purple-300 { @apply text-[#CE93D8]; } /* Light Purple for shadow names */

    #lista-itens .text-xs.text-slate-300, /* Item effects description */
    #recipiente-sombras-container .text-slate-400 { /* "Empty" message for shadows */
        @apply text-[#BCAAA4]; /* Muted Light Brown */
    }

    /* Mercador Screen */
    #mercador-screen h2 { @apply text-[#E0C097] border-b-2 border-[#6D4C41] pb-2; }
    #mercador-screen .bg-slate-700 { /* Container for merchant items */
        background-color: rgba(93, 64, 55, 0.4);
        border: 1px solid #4E342E;
    }
    #mercador-screen #lista-mercador li {
        background-color: rgba(83, 60, 47, 0.5) !important;
        border: 1px solid #786054;
    }
    #mercador-screen #lista-mercador .font-semibold.text-sky-400 { /* Item name */
        @apply text-[#90CAF9]; /* Light Blue for item names */
    }
    #mercador-screen #lista-mercador .text-xs.text-slate-300 { /* Item effects */
        @apply text-[#BCAAA4]; /* Muted Light Brown */
    }
    #mercador-screen #lista-mercador .font-semibold.text-amber-300 { /* Price */
        @apply text-[#FFCA28]; /* Amber/Gold */
    }

    /* Battle Interface Container */
    #battle-interface-container {
        background-color: rgba(60, 45, 38, 0.4); /* Semi-transparent Darker Brown #3C2D26 base */
    }
    #player-battle-display, #enemy-battle-display, #summon-battle-display {
        background-color: rgba(93, 64, 55, 0.5) !important; /* #5D4037 base, Semi-transparent cards */
        border: 1px solid #4E342E; /* Dark Brown border */
    }

    /* Footer command bar */
    footer.bg-slate-900 { /* Was: #5D4037 */
        @apply bg-[#2A1F1B] border-t-2 border-[#1F1611]; /* Match header */
    }
    #chat-command-input {
        @apply bg-[#4E342E] text-[#E0C097] border-[#6D4C41] placeholder-[#A1887F]; /* Dark Brown bg, Parchment text, Wood Brown border, Muted Brown placeholder */
        @apply focus:ring-[#786054] focus:border-[#786054];
        font-family: 'Merriweather', serif;
    }
    #btn-send-command {
        @apply bg-[#6D4C41] hover:bg-[#543C32] text-[#FFF8E1]; /* Wood Brown bg, Cornsilk text */
        font-family: 'Merriweather', serif;
    }

    /* Boss Door Visual */
    #boss-door-visual {
        /* Styles remain mostly the same as it's an overlay */
        /* ... */
        border: 5px solid #1F1611; /* Even darker border to match header style */
    }
    /* .hide-game-content remains the same */

    /* Character Setup Screen */
    #character-setup-screen {
        background-color: #31251E !important; /* Override inline style for old paper */
        border: 2px solid #1F1611 !important;
    }
    #character-setup-screen h2 { @apply text-[#E0C097]; }
    #character-setup-screen label { @apply text-[#BCAAA4]; }
    #character-setup-screen input[type="text"] {
        @apply bg-[#4E342E] text-[#E0C097] border-[#6D4C41] placeholder-[#A1887F] focus:ring-[#786054] focus:border-[#786054];
    }
    #character-setup-screen p.text-xs { @apply text-[#A1887F]; }
    #btn-save-character-setup {
         @apply bg-[#6D4C41] hover:bg-[#543C32] text-[#FFF8E1] border border-[#4E342E];
    }

    </style>
</head>

<body class="min-h-screen flex flex-col bg-theme-default">
    <header class="bg-slate-900 p-4 flex justify-between items-center shadow-lg sticky top-0 z-50">
        <h1 class="text-2xl font-extrabold tracking-wide select-none">Arkham</h1>
        <nav class="flex space-x-4 items-center">
            <button id="btn-inicio" aria-label="Início" class="p-2 disabled:opacity-50 disabled:cursor-not-allowed"
                title="Início">
                <i class="fas fa-home fa-lg"></i>
            </button>
            <button id="btn-atributos" aria-label="Distribuir Atributos"
                class="p-2 disabled:opacity-50 disabled:cursor-not-allowed" title="Distribuir Atributos">
                <i class="fas fa-dumbbell fa-lg"></i>
            </button>
            <button id="btn-skills" aria-label="Habilidades" class="p-2 disabled:opacity-50 disabled:cursor-not-allowed"
                title="Habilidades">
                <i class="fas fa-book fa-lg"></i>
            </button>
            <button id="btn-inventario" aria-label="Inventário"
                class="p-2 disabled:opacity-50 disabled:cursor-not-allowed" title="Inventário">
                <i class="fas fa-box-open fa-lg"></i>
            </button>
            <button id="btn-mercador" aria-label="Mercador" class="p-2 hidden" title="Mercador">
                <i class="fas fa-store fa-lg"></i>
            </button>

            <button id="btn-save-google" aria-label="Salvar Progresso Google" class="p-2 hidden"
                title="Salvar Progresso Google">
                <i class="fas fa-save fa-lg"></i>
            </button>
            <div id="google-signin-button-container" class="mx-1">
                <div id="g_id_signin_button_div"></div>
            </div>
            <span id="google-user-greeting" class="hidden text-sm"></span>
            <button id="btn-signout-google" aria-label="Sair da Conta Google" class="p-2 hidden"
                title="Sair da Conta Google">
                <i class="fas fa-door-open fa-lg"></i>
            </button>

            <button id="btn-sair" aria-label="Sair do Jogo" class="p-2 disabled:opacity-50 disabled:cursor-not-allowed"
                title="Sair do Jogo">
                <i class="fas fa-sign-out-alt fa-lg"></i>
            </button>
        </nav>
    </header>

    <div id="game-container" class="flex-1 flex flex-col overflow-hidden">
        <section id="character-setup-screen"
            class="max-w-xl mx-auto p-6 space-y-6 bg-[#f5e8c8] border-2 border-[#4e342e] rounded-lg shadow-xl hidden"
            style="background-image: none;">
            <h2 class="text-3xl font-extrabold text-center tracking-wider">Crie seu Herói</h2>
            <div class="space-y-4">
                <div>
                    <label for="player-name-input" class="block text-sm font-medium mb-1">Nome do Personagem:</label>
                    <input type="text" id="player-name-input" value="Herói" class="w-full p-2 rounded"
                        placeholder="Digite o nome do seu herói">
                </div>
                <div>
                    <label for="player-portrait-input" class="block text-sm font-medium mb-1">URL da Imagem do Retrato
                        (opcional):</label>
                    <input type="text" id="player-portrait-input" class="w-full p-2 rounded"
                        placeholder="https://exemplo.com/imagem.png">
                    <p class="text-xs mt-1">Deixe em branco para usar o retrato padrão. Use uma URL de imagem quadrada
                        (ex: 48x48px).</p>
                </div>
            </div>
            <div class="text-center">
                <button id="btn-save-character-setup" class="rounded-lg px-8 py-3 font-semibold text-lg">
                    Confirmar e Iniciar Aventura
                </button>
            </div>
        </section>
        <main id="main-content" class="flex-1 p-6 overflow-y-auto max-h-screen pb-20">
            <section id="game-screen" class="max-w-4xl mx-auto space-y-6">
                <div id="story-text" class="rounded-lg p-6 min-h-[180px] select-text">Texto da história apareceria
                    aqui...</div>
                <div id="choices" class="flex flex-col space-y-3"></div>

                <div id="battle-interface-container" class="hidden mt-4 p-4 rounded-lg shadow-xl">
                    <div class="flex flex-col md:flex-row gap-4">
                        <div id="battle-party-pane" class="flex-grow space-y-3 md:w-3/5">
                            <div id="player-battle-display" class="p-3 rounded">
                                <div class="flex items-center mb-2">
                                    <img id="player-battle-portrait" src="https://via.placeholder.com/48?text=P"
                                        alt="Player" class="w-12 h-12 rounded-full mr-3 border-2 border-[#A1887F]">
                                    <div id="player-battle-name" class="text-xl font-semibold">Herói</div>
                                </div>
                                <div class="mb-1">
                                    <div class="flex justify-between text-xs text-slate-300"><span>HP</span><span
                                            id="player-battle-hp-text">100/100</span></div>
                                    <div class="w-full bg-slate-600 rounded-full h-3 overflow-hidden">
                                        <div id="player-battle-hp-bar"
                                            class="h-3 rounded-full transition-all duration-300 ease-out"
                                            style="width:100%"></div>
                                    </div>
                                </div>
                                <div class="mb-1">
                                    <div class="flex justify-between text-xs text-slate-300"><span>MP</span><span
                                            id="player-battle-mp-text">50/50</span></div>
                                    <div class="w-full bg-slate-600 rounded-full h-3 overflow-hidden">
                                        <div id="player-battle-mp-bar"
                                            class="h-3 rounded-full transition-all duration-300 ease-out"
                                            style="width:100%"></div>
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between text-xs text-slate-300"><span>XP</span><span
                                            id="player-battle-xp-text">0/100</span></div>
                                    <div class="w-full bg-slate-600 rounded-full h-3 overflow-hidden">
                                        <div id="player-battle-xp-bar"
                                            class="h-3 rounded-full transition-all duration-300 ease-out"
                                            style="width:0%"></div>
                                    </div>
                                </div>
                            </div>
                            <div id="summon-battle-display" class="p-3 rounded hidden">
                                <div class="flex items-center mb-2">
                                    <img id="summon-battle-portrait" src="https://via.placeholder.com/40?text=S"
                                        alt="Summon" class="w-10 h-10 rounded-full mr-3 border-2 border-[#8D6E63]">
                                    <div id="summon-battle-name" class="text-lg font-semibold">Sombra</div>
                                </div>
                                <div>
                                    <div class="flex justify-between text-xs text-slate-300"><span>HP</span><span
                                            id="summon-battle-hp-text">50/50</span></div>
                                    <div class="w-full bg-slate-600 rounded-full h-2.5 overflow-hidden">
                                        <div id="summon-battle-hp-bar"
                                            class="h-2.5 rounded-full transition-all duration-300 ease-out"
                                            style="width:100%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="enemy-battle-display" class="p-3 rounded md:w-2/5">
                            <div class="flex items-center mb-2">
                                <img id="enemy-battle-portrait" src="https://via.placeholder.com/48?text=E" alt="Enemy"
                                    class="w-12 h-12 rounded-full mr-3 border-2 border-[#A1887F]">
                                <div id="enemy-battle-name" class="text-xl font-semibold">Monstro</div>
                            </div>
                            <div>
                                <div class="flex justify-between text-xs text-slate-300"><span>HP</span><span
                                        id="enemy-battle-hp-text">120/120</span></div>
                                <div class="w-full bg-slate-600 rounded-full h-3 overflow-hidden">
                                    <div id="enemy-battle-hp-bar"
                                        class="h-3 rounded-full transition-all duration-300 ease-out"
                                        style="width:100%"></div>
                                </div>
                                <div id="enemy-battle-rank" class="text-xs mt-1">Rank E</div>
                            </div>
                        </div>
                    </div>

                    <div id="battle-main-commands" class="mt-4 grid grid-cols-2 sm:grid-cols-4 gap-2">
                        <button id="btn-battle-fight">Usar Arma</button>
                        <button id="btn-battle-skill">Habilidade</button>
                        <button id="btn-battle-item">Item</button>
                        <button id="btn-battle-escape">Fugir</button>
                    </div>
                    <div id="battle-submenu-choices" class="mt-3 flex flex-col space-y-2"></div>
                </div>
            </section>

            <section id="atributos-screen" class="max-w-4xl mx-auto space-y-6 hidden atributos-fundo">
                <div class="aetherLay">
                    <h2 class="text-3xl font-extrabold mb-6 text-center tracking-wider">VISÃO GERAL DO HERÓI</h2>
                    <div class="atributosLay">
                        <div class="bg-slate-700 rounded-xl shadow-xl p-6 mb-8">
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 text-center">
                                <div class="bg-slate-600 p-3 rounded-lg shadow-md">
                                    <div class="text-sm uppercase tracking-wider text-slate-400">Nível</div>
                                    <div id="status-nivel" class="text-2xl font-bold">1</div>
                                </div>
                                <div class="bg-slate-600 p-3 rounded-lg shadow-md">
                                    <div class="text-sm uppercase tracking-wider text-slate-400">Rank</div>
                                    <div id="status-rank" class="text-2xl font-bold">E</div>
                                </div>
                                <div class="bg-slate-600 p-3 rounded-lg shadow-md">
                                    <div class="text-sm uppercase tracking-wider text-slate-400">Classe</div>
                                    <div id="status-classe" class="text-lg font-bold truncate" title="Nenhuma">Nenhuma
                                    </div>
                                </div>
                                <div class="bg-slate-600 p-3 rounded-lg shadow-md">
                                    <div class="text-sm uppercase tracking-wider text-slate-400">Moedas</div>
                                    <div id="status-moedas" class="text-2xl font-bold">0</div>
                                </div>
                            </div>
                            <div class="mb-6 bg-slate-600 p-4 rounded-lg shadow-md">
                                <div class="flex justify-between text-sm mb-1 items-center">
                                    <span class="font-semibold text-purple-300"><i
                                            class="fas fa-dice-d20 mr-2"></i>EXPERIÊNCIA</span>
                                    <span class="font-mono"><span id="status-xp">0</span> / <span
                                            id="status-xpProximo">100</span></span>
                                </div>
                                <div
                                    class="w-full bg-slate-800 rounded-full h-4 overflow-hidden border-2 border-slate-500 shadow-inner">
                                    <div id="status-xp-bar"
                                        class="h-full rounded-full transition-all duration-300 ease-out"
                                        style="width:0%"></div>
                                </div>
                            </div>
                            <div class="grid md:grid-cols-2 gap-6 mb-6">
                                <div class="bg-slate-600 p-4 rounded-lg shadow-md">
                                    <div class="flex justify-between items-center mb-1">
                                        <span class="text-lg font-semibold text-red-400"><i
                                                class="fas fa-heart mr-2"></i>VIDA</span>
                                        <span id="status-vida" class="text-lg font-mono">0/0</span>
                                    </div>
                                    <div
                                        class="w-full bg-slate-800 rounded-full h-5 overflow-hidden border-2 border-slate-500 shadow-inner mb-2">
                                        <div id="status-vida-bar"
                                            class="h-full rounded-full transition-all duration-300 ease-out"
                                            style="width:100%"></div>
                                    </div>
                                    <div class="text-xs text-slate-400 text-right">Bônus de Vitalidade: +<span
                                            id="bonus-vida-max-val">0</span> HP</div>
                                </div>
                                <div class="bg-slate-600 p-4 rounded-lg shadow-md">
                                    <div class="flex justify-between items-center mb-1">
                                        <span class="text-lg font-semibold text-blue-400"><i
                                                class="fas fa-bolt mr-2"></i>MANA</span>
                                        <span id="status-mana" class="text-lg font-mono">0/0</span>
                                    </div>
                                    <div
                                        class="w-full bg-slate-800 rounded-full h-5 overflow-hidden border-2 border-slate-500 shadow-inner mb-2">
                                        <div id="status-mana-bar"
                                            class="h-full rounded-full transition-all duration-300 ease-out"
                                            style="width:100%"></div>
                                    </div>
                                    <div class="text-xs text-slate-400 text-right">Bônus de Inteligência: +<span
                                            id="bonus-mana-max-val">0</span> MP</div>
                                </div>
                            </div>
                            <h4 class="text-xl font-semibold mb-4 mt-8 text-center tracking-wide">ATRIBUTOS DE COMBATE
                            </h4>
                            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 text-sm select-none">
                                <div class="bg-slate-600 p-3 rounded-lg text-center shadow-md">
                                    <div class="text-xs uppercase tracking-wider text-slate-400 mb-1">Dano Físico</div>
                                    <div id="bonus-dano-fisico" class="text-xl font-bold">0</div>
                                </div>
                                <div class="bg-slate-600 p-3 rounded-lg text-center shadow-md">
                                    <div class="text-xs uppercase tracking-wider text-slate-400 mb-1">Dano Mágico</div>
                                    <div id="bonus-dano-magico" class="text-xl font-bold">0</div>
                                </div>
                                <div class="bg-slate-600 p-3 rounded-lg text-center shadow-md">
                                    <div class="text-xs uppercase tracking-wider text-slate-400 mb-1">Redução de Dano
                                    </div>
                                    <div class="text-xl font-bold"><span id="bonus-resistencia">0</span>%</div>
                                </div>
                                <div class="bg-slate-600 p-3 rounded-lg text-center shadow-md">
                                    <div class="text-xs uppercase tracking-wider text-slate-400 mb-1">Esquiva / Fuga
                                    </div>
                                    <div>
                                        <span class="text-lg font-semibold" title="Chance de Esquiva"><i
                                                class="fas fa-shield-alt mr-1"></i><span
                                                id="bonus-esquiva">0</span>%</span> /
                                        <span class="text-lg font-semibold" title="Chance de Fuga"><i
                                                class="fas fa-shoe-prints mr-1"></i><span
                                                id="bonus-fuga">0</span>%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <p class="mb-2 text-center">Você tem <span id="pontos-disponiveis"
                                class="font-semibold text-xl">0</span> pontos para distribuir.</p>
                        <div class="mb-4 text-center">
                            <h4 class="text-lg font-semibold mb-2">Definir Adição por Clique:</h4>
                            <div id="attribute-add-mode" class="inline-flex rounded-md shadow-sm" role="group">
                                <button type="button"
                                    class="px-4 py-2 text-sm font-medium border border-gray-600 rounded-l-lg hover:bg-[#543C32] focus:z-10 focus:ring-2 focus:ring-[#A1887F] bg-[#6D4C41] text-[#FFF8E1] attribute-mode-btn"
                                    data-amount="1">
                                    +1
                                </button>
                                <button type="button"
                                    class="px-4 py-2 text-sm font-medium border-t border-b border-gray-600 hover:bg-[#543C32] focus:z-10 focus:ring-2 focus:ring-[#A1887F] bg-[#6D4C41] text-[#FFF8E1] attribute-mode-btn"
                                    data-amount="5">
                                    +5
                                </button>
                                <button type="button"
                                    class="px-4 py-2 text-sm font-medium border-t border-b border-gray-600 hover:bg-[#543C32] focus:z-10 focus:ring-2 focus:ring-[#A1887F] bg-[#6D4C41] text-[#FFF8E1] attribute-mode-btn"
                                    data-amount="10">
                                    +10
                                </button>
                                <button type="button"
                                    class="px-4 py-2 text-sm font-medium border border-gray-600 rounded-r-lg hover:bg-[#543C32] focus:z-10 focus:ring-2 focus:ring-[#A1887F] bg-[#6D4C41] text-[#FFF8E1] attribute-mode-btn"
                                    data-amount="100">
                                    +100
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                            <div class="bg-slate-700 p-4 rounded-lg flex flex-col items-center space-y-2 shadow-lg">
                                <span class="font-semibold text-lg"><i
                                        class="fas fa-fist-raised mr-2 text-red-400"></i>Força</span>
                                <div class="flex items-center space-x-2">
                                    <button data-attr="forca" data-action="dec" class="btn-attr"><i
                                            class="fas fa-minus"></i></button>
                                    <span id="forca-val" class="w-12 text-center font-mono text-xl">0.0</span>
                                    <span id="forca-rank" class="w-8 text-center text-sm font-mono">(E)</span>
                                    <button data-attr="forca" data-action="inc" class="btn-attr"><i
                                            class="fas fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="bg-slate-700 p-4 rounded-lg flex flex-col items-center space-y-2 shadow-lg">
                                <span class="font-semibold text-lg"><i
                                        class="fas fa-running mr-2 text-green-400"></i>Agilidade</span>
                                <div class="flex items-center space-x-2">
                                    <button data-attr="agilidade" data-action="dec" class="btn-attr"><i
                                            class="fas fa-minus"></i></button>
                                    <span id="agilidade-val" class="w-12 text-center font-mono text-xl">0.0</span>
                                    <span id="agilidade-rank" class="w-8 text-center text-sm font-mono">(E)</span>
                                    <button data-attr="agilidade" data-action="inc" class="btn-attr"><i
                                            class="fas fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="bg-slate-700 p-4 rounded-lg flex flex-col items-center space-y-2 shadow-lg">
                                <span class="font-semibold text-lg"><i
                                        class="fas fa-brain mr-2 text-blue-400"></i>Inteligência</span>
                                <div class="flex items-center space-x-2">
                                    <button data-attr="inteligencia" data-action="dec" class="btn-attr"><i
                                            class="fas fa-minus"></i></button>
                                    <span id="inteligencia-val" class="w-12 text-center font-mono text-xl">0.0</span>
                                    <span id="inteligencia-rank" class="w-8 text-center text-sm font-mono">(E)</span>
                                    <button data-attr="inteligencia" data-action="inc" class="btn-attr"><i
                                            class="fas fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="bg-slate-700 p-4 rounded-lg flex flex-col items-center space-y-2 shadow-lg">
                                <span class="font-semibold text-lg"><i
                                        class="fas fa-shield-alt mr-2 text-gray-400"></i>Resistência</span>
                                <div class="flex items-center space-x-2">
                                    <button data-attr="resistencia" data-action="dec" class="btn-attr"><i
                                            class="fas fa-minus"></i></button>
                                    <span id="resistencia-val" class="w-12 text-center font-mono text-xl">0.0</span>
                                    <span id="resistencia-rank" class="w-8 text-center text-sm font-mono">(E)</span>
                                    <button data-attr="resistencia" data-action="inc" class="btn-attr"><i
                                            class="fas fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="bg-slate-700 p-4 rounded-lg flex flex-col items-center space-y-2 shadow-lg">
                                <span class="font-semibold text-lg"><i
                                        class="fas fa-heartbeat mr-2 text-pink-400"></i>Vitalidade</span>
                                <div class="flex items-center space-x-2">
                                    <button data-attr="vitalidade" data-action="dec" class="btn-attr"><i
                                            class="fas fa-minus"></i></button>
                                    <span id="vitalidade-val" class="w-12 text-center font-mono text-xl">0.0</span>
                                    <span id="vitalidade-rank" class="w-8 text-center text-sm font-mono">(E)</span>
                                    <button data-attr="vitalidade" data-action="inc" class="btn-attr"><i
                                            class="fas fa-plus"></i></button>
                                </div>
                            </div>
                            <div class="bg-slate-700 p-4 rounded-lg flex flex-col items-center space-y-2 shadow-lg">
                                <span class="font-semibold text-lg"><i
                                        class="fas fa-eye mr-2 text-yellow-400"></i>Percepção</span>
                                <div class="flex items-center space-x-2">
                                    <button data-attr="percepcao" data-action="dec" class="btn-attr"><i
                                            class="fas fa-minus"></i></button>
                                    <span id="percepcao-val" class="w-12 text-center font-mono text-xl">0.0</span>
                                    <span id="percepcao-rank" class="w-8 text-center text-sm font-mono">(E)</span>
                                    <button data-attr="percepcao" data-action="inc" class="btn-attr"><i
                                            class="fas fa-plus"></i></button>
                                </div>
                            </div>
                        </div>
                        <div class="text-center mt-8">
                            <button id="btn-salvar-atributos" class="rounded-lg px-8 py-3 font-semibold text-lg">Salvar
                                Atributos e Voltar</button>
                        </div>
                    </div>
                </div>
            </section>

            <section id="skills-screen" class="max-w-4xl mx-auto space-y-6 hidden">
                <h2 class="text-2xl font-bold mb-4">Habilidades de Classe</h2>
                <div id="classe-info-skills" class="mb-4 text-lg"></div>
                <div id="lista-skills" class="rounded-lg p-4 max-h-[450px] overflow-y-auto space-y-4">
                </div>
                <p class="mt-4 text-sm italic">Habilidades são desbloqueadas ao atingir certos níveis após sua classe
                    ser definida. Você pode equipar até 4 habilidades.</p>
            </section>

            <section id="inventario-screen" class="max-w-4xl mx-auto space-y-6 hidden">
                <h2 class="text-2xl font-bold mb-4">Inventário</h2>
                <div class="flex flex-col md:flex-row gap-6">
                    <div class="flex-1 bg-slate-700 rounded-lg p-4 max-h-[500px] overflow-y-auto">
                        <h3 class="font-semibold mb-3 text-lg border-b pb-2">Itens</h3>
                        <ul id="lista-itens" class="space-y-2 text-sm"></ul>
                    </div>
                    <div class="flex-1 bg-slate-700 rounded-lg p-4">
                        <h3 class="font-semibold mb-3 text-lg border-b pb-2">Equipamentos</h3>
                        <div class="inventory-equip-layout">
                            <div
                                class="character-placeholder-container bg-slate-600 p-4 rounded-lg items-center justify-center flex">
                                <i class="fas fa-male fa-9x"></i>
                            </div>
                            <div class="equipment-grid-container">
                                <div class="equipment-grid">
                                    <div>
                                        <span class="equipment-slot-label">Capacete:</span>
                                        <div id="equip-capacete" class="equipment-slot-display">Nenhum</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Colar:</span>
                                        <div id="equip-colar" class="equipment-slot-display">Nenhum</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Peitoral:</span>
                                        <div id="equip-peitoral" class="equipment-slot-display">Nenhum</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Arma:</span>
                                        <div id="equip-arma" class="equipment-slot-display">Nenhuma</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Calça:</span>
                                        <div id="equip-calca" class="equipment-slot-display">Nenhuma</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Anel:</span>
                                        <div id="equip-anel" class="equipment-slot-display">Nenhum</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Botas:</span>
                                        <div id="equip-botas" class="equipment-slot-display">Nenhuma</div>
                                    </div>
                                    <div>
                                        <span class="equipment-slot-label">Escudo:</span>
                                        <div id="equip-escudo" class="equipment-slot-display">Nenhum</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="recipiente-sombras-container" class="mt-6 hidden">
                    <h3 class="text-xl font-bold mb-3 border-b pb-2">Recipiente de Sombras</h3>
                    <div class="bg-slate-700 rounded-lg p-4 max-h-[300px] overflow-y-auto">
                        <ul id="lista-sombras-recipiente" class="space-y-2 text-sm"></ul>
                    </div>
                </div>
            </section>

            <section id="mercador-screen" class="max-w-4xl mx-auto space-y-6 hidden">
                <h2 class="text-2xl font-bold mb-4">Mercador</h2>
                <p class="mb-4">O mercador aparece a cada 5 níveis e oferece itens para venda.</p>
                <div class="bg-slate-700 rounded-lg p-4 max-h-[400px] overflow-y-auto">
                    <ul id="lista-mercador" class="space-y-4"></ul>
                </div>
                <button id="btn-comprar-mercador"
                    class="mt-4 rounded px-6 py-2 font-semibold disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled>Comprar Selecionados</button>
            </section>
        </main>
    </div>

    <footer class="p-2 fixed bottom-0 left-0 right-0 z-50 shadow-lg hidden">
        <div class="max-w-4xl mx-auto flex items-center space-x-2">
            <input type="text" id="chat-command-input" class="flex-1 rounded px-3 py-1.5 text-sm"
                placeholder="Digite um comando...">
            <button id="btn-send-command" class="rounded px-4 py-1.5 text-sm font-semibold">Enviar</button>
        </div>
    </footer>

    <div id="boss-door-visual" class="hidden"> <img
            src="https://source.unsplash.com/random/800x600/?fantasy,gate,door,ancient,stone,dark" alt="Porta do Chefe">
    </div>

    <script>
        (() => {
            const commandFooter = document.querySelector('footer');
            const chatInputForFocus = document.getElementById('chat-command-input');

            document.addEventListener('keydown', function (event) {
                if (event.shiftKey && (event.key === 'W' || event.key === 'w')) {
                    event.preventDefault();

                    if (commandFooter) {
                        commandFooter.classList.toggle('hidden');
                        if (!commandFooter.classList.contains('hidden') && chatInputForFocus) {
                            chatInputForFocus.focus();
                        }
                    }
                }
            });

            document.getElementById("btn-inicio")?.addEventListener("click", abrirInicio);

            "use strict";

            let googleDecodedCredential = null;
            let isGoogleSignedIn = false;
            const GOOGLE_SAVE_KEY_PREFIX = "aethelRPG_save_";
            const GOOGLE_CLIENT_ID = "202996671264-22eoon8o5ksj4pnu699988cic0oqp6mn.apps.googleusercontent.com";

            const RANKS = ["E", "D", "C", "B", "A", "S"];
            const RANK_MIN_TOTAL = { E: 0, D: 55, C: 140, B: 320, A: 460, S: 660 };
            const BASE_STATS = { forca: 0, agilidade: 0, inteligencia: 0, resistencia: 0, vitalidade: 0, percepcao: 0 };
            const BASE_HP = 100;
            const BASE_MANA = 10;
            const BASE_DANO_FISICO = 10;
            const BASE_DANO_MAGICO = 10;
            const BASE_RESISTENCIA = 0;
            const FUGIR_PCT_DECREMENTO = 0.07;
            const XP_BONUS_GLOBAL = 1.0;

            const MANA_GASTO_PCT = { E: 0.10, D: 0.15, C: 0.20, B: 0.25, A: 0.30, S: 0.35 };

            const PLAYER_CLASSES_LIST = ["Guerreiro", "Arqueiro", "Mago", "Assassino", "Paladino", "Bardo", "Necromante"];

            const ATTR_RANK_THRESHOLDS_MAP = [
                { rank: "S", min: 660 },
                { rank: "A", min: 460 },
                { rank: "B", min: 320 },
                { rank: "C", min: 140 },
                { rank: "D", min: 55 },
                { rank: "E", min: 0 }
            ];
            const INDIVIDUAL_ATTRIBUTE_RANK_THRESHOLDS = [
                { rank: "S", min: RANK_MIN_TOTAL.S / 6 }, // Approx 18.33
                { rank: "A", min: RANK_MIN_TOTAL.A / 6 }, // 13
                { rank: "B", min: RANK_MIN_TOTAL.B / 6 }, // 9
                { rank: "C", min: RANK_MIN_TOTAL.C / 6 }, // 4
                { rank: "D", min: RANK_MIN_TOTAL.D / 6 }, // Approx 1.67
                { rank: "E", min: RANK_MIN_TOTAL.E / 6 }  // 0
            ];
            const TIPOS_DE_ARMAS = {
                "Nenhuma": {
                    nomeDisplay: "Desarmado",
                    habilidades: [
                        { id: "desarmado_soco", nome: "Soco Certeiro", descricao: "Um soco rápido no alvo.", danoMultiplicador: 0.8, custoMana: 0, rank: "E" },
                        { id: "desarmado_chute", nome: "Chute Baixo", descricao: "Um chute nas pernas do inimigo.", danoMultiplicador: 1.0, custoMana: 0, rank: "E" },
                        { id: "desarmado_empurrao", nome: "Empurrão", descricao: "Tenta desequilibrar o alvo, causando pouco dano.", danoMultiplicador: 0.5, custoMana: 0, rank: "E" }
                    ]
                },
                "Espada": {
                    nomeDisplay: "Espada",
                    habilidades: [
                        { id: "espada_corte_rapido", nome: "Corte Rápido", descricao: "Um golpe veloz e preciso.", danoMultiplicador: 1.7, custoMana: 0, rank: "C" },
                        { id: "espada_estocada", nome: "Estocada Perfurante", descricao: "Uma estocada que busca um ponto vital.", danoMultiplicador: 1.5, custoMana: 8, rank: "B" },
                        { id: "espada_lamina_giratoria", nome: "Lâmina Giratória", descricao: "Um ataque amplo que pode desorientar.", danoMultiplicador: 2, custoMana: 12, rank: "A", efeito: { tipo: "debuff_precisao_inimigo", valor: 0.1, duracao: 2 } }
                    ]
                },
                "Clava": {
                    nomeDisplay: "Clava",
                    habilidades: [
                        { id: "clava_pancada", nome: "Pancada Pesada", descricao: "Um golpe lento, mas com força.", danoMultiplicador: 1.6, custoMana: 0, rank: "C" },
                        { id: "clava_esmagar_cranio", nome: "Esmagar Crânio", descricao: "Um golpe poderoso com chance de atordoar.", danoMultiplicador: 1.6, custoMana: 10, rank: "B", efeito: { tipo: "chance_atordoar", chance: 0.25 } },
                        { id: "clava_impacto_brutal", nome: "Impacto Brutal", descricao: "Reduz a defesa do alvo com um golpe esmagador.", danoMultiplicador: 1.5, custoMana: 15, rank: "A", efeito: { tipo: "debuff_defesa_inimigo", valor: 0.15, duracao: 3 } }
                    ]
                },
                "Lança": {
                    nomeDisplay: "Lança",
                    habilidades: [
                        { id: "lanca_investida", nome: "Investida de Lança", descricao: "Avança rapidamente para perfurar.", danoMultiplicador: 1.5, custoMana: 0, rank: "C" },
                        { id: "lanca_empalar", nome: "Empalar", descricao: "Causa dano e sangramento.", danoMultiplicador: 1.0, custoMana: 10, rank: "B", efeito: { tipo: "dot", dano_por_turno: 5, duracao: 3, tipoDanoDot: "fisico" } },
                        { id: "lanca_varredura", nome: "Varredura Defensiva", descricao: "Um golpe para manter distância, chance de recuar.", danoMultiplicador: 1.9, custoMana: 14, rank: "A" /* Efeito de recuo pode ser complexo, manter simples por ora */ }
                    ]
                },
                "Arco": {
                    nomeDisplay: "Arco",
                    habilidades: [
                        { id: "arco_tiro_preciso", nome: "Tiro Preciso", descricao: "Um disparo focado no ponto fraco.", danoMultiplicador: 1.4, custoMana: 0, rank: "C" },
                        { id: "arco_flecha_farpada", nome: "Flecha Farpada", descricao: "Causa sangramento ao ser removida.", danoMultiplicador: 1.5, custoMana: 9, rank: "B", efeito: { tipo: "dot", dano_por_turno: 4, duracao: 3, tipoDanoDot: "fisico" } },
                        { id: "arco_tiro_duplo", nome: "Tiro Duplo", descricao: "Dispara duas flechas em rápida sucessão.", danoMultiplicador: 2, custoMana: 13, rank: "A", hits: 2 }
                    ]
                },
                "Besta": {
                    nomeDisplay: "Besta",
                    habilidades: [
                        { id: "besta_virote_pesado", nome: "Virote Pesado", descricao: "Um tiro potente que ignora parte da armadura.", danoMultiplicador: 1.7, custoMana: 0, rank: "C", efeito: { tipo: "ignora_defesa_parcial", valor: 0.1 } },
                        { id: "besta_tiro_incapacitante", nome: "Tiro Incapacitante", descricao: "Mira nas juntas para dificultar o movimento.", danoMultiplicador: 15, custoMana: 11, rank: "B", efeito: { tipo: "debuff_agilidade_inimigo", valor: 0.1, duracao: 2 } },
                        { id: "besta_recarga_rapida", nome: "Recarga Rápida", descricao: "Prepara um tiro extra para o próximo turno ou causa dano extra imediato.", danoMultiplicador: 1.8, custoMana: 16, rank: "A" }
                    ]
                },
                "Manoplas": {
                    nomeDisplay: "Manoplas",
                    habilidades: [
                        { id: "manoplas_soco_veloz", nome: "Soco Veloz", descricao: "Uma sequência rápida de golpes.", danoMultiplicador: 1, custoMana: 0, rank: "C", hits: 2 },
                        { id: "manoplas_quebra_guarda", nome: "Quebra-Guarda", descricao: "Um golpe forte para abrir a defesa inimiga.", danoMultiplicador: 1.7, custoMana: 9, rank: "B", efeito: { tipo: "debuff_defesa_inimigo", valor: 0.1, duracao: 2 } },
                        { id: "manoplas_impacto_feroz", nome: "Impacto Feroz", descricao: "Concentra energia em um golpe devastador.", danoMultiplicador: 1.9, custoMana: 14, rank: "A" }
                    ]
                },
                "Atomic": {
                    nomeDisplay: "Atomic",
                    habilidades: [
                        {
                            id: "atomic_speed_slash",
                            nome: "Speed Slash",
                            descricao: "Um ataque padrão ultra-rápido que causa 600 de dano.",
                            danoBase: 600, // Usaremos danoBase para dano fixo desta habilidade
                            custoMana: 0,
                            rank: "SSS",
                            tipoDano: "fisico" // Assuming physical, adjust if needed
                        },
                        {
                            id: "atomic_time_stop",
                            nome: "Time Stop",
                            descricao: "Para o tempo, fazendo o inimigo não atacar por 2 turnos.",
                            custoManaPercent: 0.50, // 50% da mana total
                            rank: "SSS",
                            efeito: { tipo: "enemy_stun_turns", duracao: 2 }
                        },
                        {
                            id: "atomic_im_atomic",
                            nome: "I'm Atomic",
                            descricao: "Uma explosão de mana que tira 90% da vida ATUAL do monstro.",
                            custoManaPercent: 0.70, // 70% da mana total
                            rank: "SSS",
                            efeito: { tipo: "damage_percentage_current_hp", valor: 0.90 }
                        },
                        {
                            id: "atomic_devastation",
                            nome: "Devastation",
                            descricao: "Múltiplos cortes devastadores. 3 cortes de 300 de dano cada.",
                            danoBase: 300, // Dano por corte
                            custoManaPercent: 0.40, // 40% da mana total
                            rank: "SSS",
                            hits: 3,
                            tipoDano: "fisico" // Assuming physical
                        }
                    ]
                }
            };

            function getAtributoRank(valor) {
                // Iterate through the new individual attribute thresholds
                for (const entry of INDIVIDUAL_ATTRIBUTE_RANK_THRESHOLDS) {
                    if (valor >= entry.min) {
                        return `(${entry.rank})`;
                    }
                }
                return "(E)"; // Default fallback if no rank is met (should hit E:0)
            }

            const CLASSES_DATA = {
                "Guerreiro": {
                    nomeDisplay: "Guerreiro",
                    descricao: "Mestre do combate corpo a corpo, focado em dano físico e resistência.",
                    habilidades: [
                        { id: "g_golpe_poderoso", nome: "Golpe Poderoso", rank: "E", danoBase: 20, manaBase: 50, unlockLevel: 1, descricao: "Um golpe concentrado que causa dano físico adicional." },
                        { id: "g_grito_guerra", nome: "Grito de Guerra", rank: "D", manaBase: 20, unlockLevel: 20, efeito: { tipo: "buff_dano_fisico", valor: 0.25, duracao: 3 }, descricao: "Aumenta o dano físico em 25% por 3 turnos." },
                        { id: "g_furia_berserker", nome: "Fúria Berserker", rank: "C", danoBase: 45, manaBase: 100, unlockLevel: 50, descricao: "Um ataque selvagem que ignora parte da defesa inimiga (causa dano verdadeiro adicional)." }
                    ]
                },
                "Arqueiro": {
                    nomeDisplay: "Arqueiro",
                    descricao: "Perito em ataques à distância, utilizando precisão e agilidade.",
                    habilidades: [
                        { id: "a_flecha_precisa", nome: "Flecha Precisa", rank: "E", danoBase: 22, manaBase: 50, unlockLevel: 1, descricao: "Um disparo certeiro com alta chance de acerto." },
                        { id: "a_chuva_flechas", nome: "Chuva de Flechas", rank: "D", danoBase: 15, manaBase: 20, unlockLevel: 20, efeito: { tipo: "multi_hit", hits: 3 }, descricao: "Dispara múltiplas flechas em rápida sucessão (3 hits)." },
                        { id: "a_tiro_perfurante", nome: "Tiro Perfurante", rank: "C", danoBase: 50, manaBase: 100, unlockLevel: 50, descricao: "Um tiro poderoso que pode perfurar a armadura do inimigo." }
                    ]
                },
                "Mago": {
                    nomeDisplay: "Mago",
                    descricao: "Conjurador de energias arcanas, especializado em dano mágico elemental.",
                    habilidades: [
                        { id: "m_seta_gelo", nome: "Seta de Gelo", rank: "E", danoBase: 25, manaBase: 15, unlockLevel: 1, descricao: "Lança uma seta de gelo que causa dano e pode desacelerar (efeito não implementado).", tipoDano: "magico" },
                        { id: "m_bola_fogo", nome: "Bola de Fogo", rank: "D", danoBase: 40, manaBase: 30, unlockLevel: 20, descricao: "Conjura uma bola de fogo explosiva.", tipoDano: "magico" },
                        { id: "m_raio_arcano", nome: "Raio Arcano", rank: "C", danoBase: 60, manaBase: 45, unlockLevel: 50, descricao: "Dispara um raio de pura energia arcana.", tipoDano: "magico" }
                    ]
                },
                "Assassino": {
                    nomeDisplay: "Assassino",
                    descricao: "Especialista em furtividade e golpes críticos, eliminando alvos rapidamente.",
                    habilidades: [
                        { id: "as_ataque_furtivo", nome: "Ataque Furtivo", rank: "E", danoBase: 18, manaBase: 10, unlockLevel: 1, efeito: { tipo: "chance_critico_bonus", valor: 0.3 }, descricao: "Golpe rápido com chance aumentada de crítico." },
                        { id: "as_golpe_venenoso", nome: "Golpe Venenoso", rank: "D", danoBase: 25, manaBase: 25, unlockLevel: 20, efeito: { tipo: "dot", dano_por_turno: 5, duracao: 3 }, descricao: "Aplica veneno que causa dano por 3 turnos." },
                        { id: "as_execucao", nome: "Execução", rank: "C", danoBase: 30, manaBase: 40, unlockLevel: 50, efeito: { tipo: "dano_bonus_vida_baixa", multiplicador: 1.5, limiar_vida: 0.3 }, descricao: "Causa dano massivo a alvos com menos de 30% de vida." }
                    ]
                },
                "Paladino": {
                    nomeDisplay: "Paladino",
                    descricao: "Guerreiro sagrado que combina proeza marcial com poderes divinos de proteção e cura.",
                    habilidades: [
                        { id: "p_golpe_divino", nome: "Golpe Divino", rank: "E", danoBase: 18, manaBase: 15, unlockLevel: 1, descricao: "Um ataque imbuído com energia sagrada.", tipoDano: "magico" },
                        { id: "p_cura_leve", nome: "Cura Leve", rank: "D", manaBase: 30, unlockLevel: 20, efeito: { tipo: "cura", valor_base: 30, escala_inteligencia: 0.5 }, descricao: "Recupera uma pequena quantidade de vida." },
                        { id: "p_escudo_santo", nome: "Escudo Santo", rank: "C", manaBase: 40, unlockLevel: 50, efeito: { tipo: "buff_resistencia", valor: 0.2, duracao: 3 }, descricao: "Aumenta a resistência do jogador em 20% por 3 turnos." }
                    ]
                },
                "Bardo": {
                    nomeDisplay: "Bardo",
                    descricao: "Mestre da música e da persuasão, usando canções para inspirar aliados e debilitar inimigos.",
                    habilidades: [
                        { id: "b_cancao_magica", nome: "Canção Mágica", rank: "C", danoBase: 50, manaCostPercent: 0.20, unlockLevel: 1, tipoDano: "magico", descricao: "Causa 50 de dano mágico. Custa 20% da mana máxima." },
                        { id: "b_milagre_musica", nome: "Milagre de Música", rank: "S", manaCostPercent: 0.50, unlockLevel: 20, efeito: { tipo: "cura_percentual_vida_max", valor: 0.4 }, descricao: "Recupera 40% da vida máxima. Custa 50% da mana máxima." },
                        { id: "b_melodia_caos", nome: "Melodia do Caos", rank: "A", danoBase: 30, manaCostPercent: 0.30, unlockLevel: 50, efeito: { tipo: "dano_caotico" }, tipoDano: "magico", descricao: "Dano e efeitos colaterais variam drasticamente com a diferença de Rank entre você e o monstro." }
                    ]
                },
                "Necromante": {
                    nomeDisplay: "Necromante",
                    descricao: "Mestre das sombras e da morte, comanda os mortos-vivos e manipula energias profanas. Pode reviver da morte sacrificando sombras.",
                    habilidades: [
                        {
                            id: "n_extracao_sombras", nome: "Extração de Sombras", rank: "D", manaBase: 25, unlockLevel: 10,
                            descricao: "Após derrotar um inimigo (não-chefe), use esta habilidade para tentar extrair sua sombra, que será armazenada no Recipiente de Sombras, um rank abaixo do original. Requer que o último monstro derrotado seja elegível.",
                            efeito: { tipo: "extracao_sombra" }
                        },
                        {
                            id: "n_invocar_sombra", nome: "Invocar Sombra", rank: "E", manaBase: 10, unlockLevel: 10,
                            descricao: "Invoca uma sombra do seu Recipiente para lutar ao seu lado (substitui a ativa, se houver). Apenas uma sombra pode estar ativa. Sombras invocadas possuem atributos baseados em sua força original.",
                            efeito: { tipo: "invocar_sombra" }
                        },
                        {
                            id: "n_dominio_sombras", nome: "Domínio das Sombras", rank: "C", manaBase: 30, unlockLevel: 20,
                            descricao: "(ATIVA) Fortalece sua sombra ativa, aumentando seu dano em 50% por 3 turnos. Requer uma sombra ativa. Desbloqueada ao vencer o Desafio do Lorde da Morte (Domínio).",
                            efeito: { tipo: "buff_dano_sombra_ativa", valor: 0.5, duracao: 3 },
                            requerDesafio: "lorde_dominio"
                        },
                        {
                            id: "n_exercito_sombras", nome: "Exército de Sombras", rank: "A", manaCostPercent: 0.60, unlockLevel: 30,
                            descricao: "Invoca temporariamente TODAS as sombras do seu Recipiente. Elas desferem um ataque conjunto devastador e depois retornam ao recipiente. Causa dano massivo baseado no número e força das sombras. Desbloqueada ao vencer o Desafio do Lorde da Morte (Exército).",
                            efeito: { tipo: "ataque_exercito_sombras_completo" },
                            tipoDano: "magico",
                            requerDesafio: "lorde_exercito"
                        },
                        {
                            id: "ms_troca_sombras", nome: "[Monarca] Troca de Sombras", rank: "S", manaBase: 100, unlockLevel: 1,
                            descricao: "Troca de lugar com uma sombra distante, permitindo escapar de qualquer batalha ou masmorra instantaneamente para o início. Custa 100 Mana.",
                            efeito: { tipo: "escape_battle_dungeon" },
                            monarcaOnly: true // Flag for Monarca specific skills
                        },
                        {
                            id: "ms_acerto_critico", nome: "[Monarca] Acerto Crítico", rank: "A", manaBase: 75, unlockLevel: 1,
                            descricao: "Desfere um golpe poderoso. Se o seu Rank for maior que o do monstro, o dano é (Dano Físico + Dano Mágico) * 2. Caso contrário, causa Dano Físico normal. Custa 75 Mana.",
                            efeito: { tipo: "critical_strike_conditional" },
                            monarcaOnly: true
                        },
                        {
                            id: "ms_recuperacao_total", nome: "[Monarca] Recuperação Total", rank: "B", manaBase: 150, unlockLevel: 1,
                            descricao: "Canaliza o poder das sombras para recuperar totalmente a Vida e a Mana. Custa 150 Mana.",
                            efeito: { tipo: "full_restore" },
                            monarcaOnly: true
                        }
                    ]
                }
            };

            const ITEM_RANKS = ["E", "D", "C", "B", "A", "S", "SS", "SSS"];
            const ITEM_BASE_PRICE = { E: 10, D: 25, C: 50, B: 100, A: 200, S: 400, SS: 600, SSS: 1000 };
            const ITEM_ATRIBUTOS_POR_RANK = {
                E: { min: 5, max: 10 }, // Adjusted from 1,3
                D: { min: 12, max: 20 }, // Adjusted from 3,5
                C: { min: 22, max: 30 }, // Adjusted from 5,7
                B: { min: 32, max: 40 }, // Adjusted from 7,10
                A: { min: 60, max: 75 }, // Adjusted from 15,20
                S: { min: 100, max: 115 }, // Adjusted from 30,40
                SS: { min: 130, max: 150 }, // New tier
                SSS: { min: 150, max: 200 }, // New tier
            };

            const POTIONS = {
                drop: { id: "potion_drop", nome: "Poção Básica", curaVidaPct: 0.4, curaManaPct: 0.2, descricao: "Recupera 40% da vida e 20% da mana." },
                compra: { id: "potion_compra", nome: "Poção Avançada", curaVidaPct: 0.7, curaManaPct: 0.5, descricao: "Recupera 70% da vida e 50% da mana." }
            };
            const ARQUITETO_STATS = {
                nome: "Arquiteto",
                rank: "SSS", // As per extreme stats
                vidaMax: 9999,
                danoFisico: 9999,
                danoMagico: 9999, // Or a portion of fisico
                xpGanho: 10000, // Or some other significant amount
                fugaPct: 0,
                isBoss: true,
                isArquiteto: true, // Special flag
                habilidades: [] // Can be left empty or given some thematic non-damaging abilities
            };
            const MONARCH_BOSS_STATS = {
                "Gelo": { nomeDisplay: "Monarca do Gelo", vida: 10000, dano: 1000, rank: "S", xp: 15000, portrait: "https://source.unsplash.com/random/48x48/?ice,monster,king,evil" },
                "Gigante": { nomeDisplay: "Monarca Gigante", vida: 15000, dano: 700, rank: "S", xp: 18000, portrait: "https://source.unsplash.com/random/48x48/?giant,monster,king,evil" },
                "Metal": { nomeDisplay: "Monarca do Metal", vida: 11000, dano: 950, rank: "S", xp: 16000, portrait: "https://source.unsplash.com/random/48x48/?metal,monster,king,evil" },
                "Transfiguracao": { nomeDisplay: "Monarca da Transfiguração", vida: 5000, dano: 500, rank: "A", xp: 12000, portrait: "https://source.unsplash.com/random/48x48/?magic,monster,king,evil" },
                "Destruicao": { nomeDisplay: "Monarca da Destruição", vida: 17000, dano: 1500, rank: "SS", xp: 25000, portrait: "https://source.unsplash.com/random/48x48/?destruction,monster,king,evil" },
                "Insetos": { nomeDisplay: "Monarca dos Insetos", vida: 8000, dano: 766, rank: "S", xp: 14000, portrait: "https://source.unsplash.com/random/48x48/?insect,monster,king,evil" },
                "Bestas": { nomeDisplay: "Monarca das Bestas", vida: 10000, dano: 900, rank: "S", xp: 15000, portrait: "https://source.unsplash.com/random/48x48/?beast,monster,king,evil" },
                "Demonio": { nomeDisplay: "Monarca Demoníaco", vida: 10666, dano: 1066, rank: "SS", xp: 22000, portrait: "https://source.unsplash.com/random/48x48/?demon,monster,king,evil" }
            };

            const DUNGEON_CONFIG = {
                "E": { name: "Masmorra Esquecida", roomsMin: 4, roomsMax: 6, monsterRank: "D", bossRank: "C", bossBaseStats: { vidaMin: 580, vidaMax: 850, danoMin: 70, danoMax: 80, xpMin: 1200, xpMax: 1800 } },
                "D": { name: "Covil Profundo", roomsMin: 5, roomsMax: 7, monsterRank: "C", bossRank: "B", bossBaseStats: { vidaMin: 1050, vidaMax: 1700, danoMin: 105, danoMax: 165, xpMin: 3500, xpMax: 5000 }, arquitetoChance: 0.05 },
                "C": { name: "Cidadela Sombria", roomsMin: 6, roomsMax: 8, monsterRank: "B", bossRank: "A", bossBaseStats: { vidaMin: 1900, vidaMax: 2500, danoMin: 170, danoMax: 205, xpMin: 7000, xpMax: 10000 } },
                "B": { name: "Fortaleza Dracônica", roomsMin: 7, roomsMax: 9, monsterRank: "A", bossRank: "S", bossBaseStats: { vidaMin: 2600, vidaMax: 4000, danoMin: 255, danoMax: 360, xpMin: 14000, xpMax: 25000 }, lordeDaMorteChance: 0.75 },
                "A": { name: "Abismo Infernal", roomsMin: 8, roomsMax: 10, monsterRank: "S", bossRank: "SS", bossBaseStats: { vidaMin: 4800, vidaMax: 7000, danoMin: 500, danoMax: 600, xpMin: 20000, xpMax: 35000 }, lordeDaMorteChance: 1 }, // Boss can now be SS
                "S": { name: "Domínio Celestial Despedaçado", roomsMin: 9, roomsMax: 12, monsterRank: "SS", bossRank: "SSS", bossBaseStats: { vidaMin: 8000, vidaMax: 11000, danoMin: 700, danoMax: 850, xpMin: 40000, xpMax: 60000 }, lordeDaMorteChance: 1.5 } // Monsters and Boss can now be SS/SSS
            };

            function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
            function randomChoice(arr) { return arr[randomInt(0, arr.length - 1)]; }
            function clamp(num, min, max) { return Math.min(Math.max(num, min), max); }
            function rankToIndex(rank) { return RANKS.indexOf(rank); }
            function indexToRank(index) { return RANKS[clamp(index, 0, RANKS.length - 1)]; }

            let game = {
                player: {
                    nome: "Herói",
                    classe: null,
                    nivel: 1,
                    xp: 0,
                    xpProximoNivel: 100,
                    rank: "E",
                    atributos: { ...BASE_STATS },
                    pontosDistribuir: 0,
                    attributeAddAmount: 1, // Padrão: adicionar 1 ponto por clique
                    vidaMax: BASE_HP,
                    vidaAtual: BASE_HP,
                    manaMax: BASE_MANA,
                    manaAtual: BASE_MANA,
                    danoFisicoBase: BASE_DANO_FISICO,
                    danoMagicoBase: BASE_DANO_MAGICO,
                    resistenciaPct: BASE_RESISTENCIA,
                    refinoMagicoPct: 0,
                    percepcaoPct: 0,
                    agilidadePctFuga: 0,
                    forcaPctDano: 0,
                    isMarcado: false,
                    isMonarcaDasSombras: false,
                    inventario: [],
                    equipamento: { capacete: null, peitoral: null, calca: null, botas: null, arma: null, escudo: null, anel: null, colar: null },
                    moedas: 100,
                    rodadas: 0,
                    xpBonus: XP_BONUS_GLOBAL,
                    magiasAdquiridas: [],
                    magiasEquipadas: [],
                    currentArea: "E",
                    currentDanoFisico: BASE_DANO_FISICO,
                    currentReducaoDano: BASE_RESISTENCIA,
                    currentChanceFuga: 0,
                    currentChanceEsquiva: 0,
                    currentDanoMagico: BASE_DANO_MAGICO,
                    activeBuffs: [],
                    recipienteSombras: [],
                    sombraAtiva: null,
                    maxActiveShadows: 1,
                    recipienteCapacity: 10,
                    lastDefeatedMonsterInfo: null,
                    metLordeDaMorte: false,
                    vitalidadeBonusVida: 0,
                    inteligenciaBonusMana: 0,
                },
                mundo: "Arkham",
                estado: "inicio",
                monstroAtual: null,
                batalha: {
                    emBatalha: false, monstro: null, turnoJogador: true, danoRecebido: 0, isBossBattle: false, isDesafioClasse: false,
                    skillEmDesafioId: null,
                    desafioBossOriginalStats: null, tipoDesafioLorde: null, jogadorAgiuNoTurno: false
                },
                mercador: { itens: [], selecionados: new Set() },
                dungeon: { active: false, name: "", typeRank: "E", totalRooms: 0, currentRoom: 0, monsterRankForRooms: "D", bossRankForDungeon: "C", bossDefeated: false, isBossRoomConfirmation: false }
            };

            const MONSTRO_NOMES = {
                E: ["Goblin Fraco", "Rato Gigante", "Lobo Selvagem", "Esqueleto Fraco", "Aranha Venenosa"],
                D: ["Goblin Guerreiro", "Lobo Alfa", "Esqueleto Guerreiro", "Aranha Gigante", "Zumbi"],
                C: ["Orc Brutal", "Troll", "Mago Sombrio", "Lobo Fantasma", "Zumbi Corrompido", "Guardião da Masmorra"],
                B: ["Orc Chefe", "Troll Ancião", "Mago Negro", "Dragão Jovem", "Zumbi Rei", "Grão-Guardião"],
                A: ["Dragão Adulto", "Lorde Orc", "Mago Supremo", "Demônio Menor", "Zumbi Lendário", "Protetor Ancestral"],
                S: ["Dragão Ancião", "Lorde Demônio", "Mago Lendário", "Deus Caído", "Zumbi Imortal", "Avatar da Destruição"],
                SS: ["Cavaleiro Abissal", "Beemote Corrompido", "Arquimago Lich", "Serpente Titânica", "Anjo Caído Vingativo"], // << NOVO
                SSS: ["Avatar Primordial", "Devorador de Mundos", "Ancião Cósmico", "Arauto do Vazio", "Deidade Esquecida"], // << NOVO
                LORDE_DA_MORTE: ["Lorde da Morte"]
            };

            function getBarPercentage(current, max) {
                if (max <= 0) return "0%";
                return clamp((current / max) * 100, 0, 100).toFixed(2) + "%";
            }

            function updatePlayerBattleDisplay() {
                const player = game.player;
                document.getElementById("player-battle-name").textContent = player.nome;
                document.getElementById("player-battle-hp-text").textContent = `${player.vidaAtual} / ${player.vidaMax}`;
                document.getElementById("player-battle-hp-bar").style.width = getBarPercentage(player.vidaAtual, player.vidaMax);
                document.getElementById("player-battle-mp-text").textContent = `${player.manaAtual} / ${player.manaMax}`;
                document.getElementById("player-battle-mp-bar").style.width = getBarPercentage(player.manaAtual, player.manaMax);
                document.getElementById("player-battle-xp-text").textContent = `${player.xp} / ${player.xpProximoNivel}`;
                document.getElementById("player-battle-xp-bar").style.width = getBarPercentage(player.xp, player.xpProximoNivel);
            }

            function updateEnemyBattleDisplay(monstro) {
                if (!monstro) return;
                document.getElementById("enemy-battle-name").textContent = monstro.nome;
                document.getElementById("enemy-battle-hp-text").textContent = `${monstro.vidaAtual} / ${monstro.vidaMax}`;
                document.getElementById("enemy-battle-hp-bar").style.width = getBarPercentage(monstro.vidaAtual, monstro.vidaMax);
                document.getElementById("enemy-battle-rank").textContent = `Rank ${monstro.rank}`;
            }

            function updateSummonBattleDisplay() {
                const summonDisplay = document.getElementById("summon-battle-display");
                if (game.player.sombraAtiva && game.player.sombraAtiva.statsAtuais) {
                    const sombra = game.player.sombraAtiva;
                    document.getElementById("summon-battle-name").textContent = sombra.nomeSombra;
                    document.getElementById("summon-battle-hp-text").textContent = `${sombra.statsAtuais.vidaAtual} / ${sombra.statsAtuais.vidaMax}`;
                    document.getElementById("summon-battle-hp-bar").style.width = getBarPercentage(sombra.statsAtuais.vidaAtual, sombra.statsAtuais.vidaMax);
                    summonDisplay.classList.remove("hidden");
                } else {
                    summonDisplay.classList.add("hidden");
                }
            }

            function showBattleInterface(show) {
                const battleContainer = document.getElementById("battle-interface-container");
                const choicesDiv = document.getElementById("choices");
                const storyText = document.getElementById("story-text");

                if (show) {
                    battleContainer.classList.remove("hidden");
                    choicesDiv.classList.add("hidden");
                    storyText.classList.remove("min-h-[180px]", "text-lg", "leading-relaxed");
                    storyText.classList.add("min-h-[100px]", "max-h-[200px]", "overflow-y-auto", "text-sm", "leading-normal");
                    updatePlayerBattleDisplay();
                    updateEnemyBattleDisplay(game.batalha.monstro);
                    updateSummonBattleDisplay();
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                } else {
                    battleContainer.classList.add("hidden");
                    choicesDiv.classList.remove("hidden");
                    storyText.classList.add("min-h-[180px]", "text-lg", "leading-relaxed");
                    storyText.classList.remove("min-h-[100px]", "max-h-[200px]", "overflow-y-auto", "text-sm", "leading-normal");
                }
            }


            function gerarMonstro(rank, isLordeDaMorte = false) {
                // Definições de dificuldade customizadas para monstros de masmorra
                const customMonsterStats = {
                    "E": { vida: 180, dano: 30 },
                    "D": { vida: 250, dano: 40 },
                    "C": { vida: 300, dano: 50 },
                    "B": { vida: 550, dano: 70 },
                    "A": { vida: 800, dano: 87 },
                    "S": { vida: 1200, dano: 100 },
                    "SS": { vida: 1600, dano: 300 }, // Adicionado para masmorras de rank A e S
                    "SSS": { vida: 2400, dano: 400 } // Adicionado para masmorras de rank S
                };

                if (isLordeDaMorte) {
                    // Lógica para o Lorde da Morte permanece inalterada
                    return {
                        nome: "Lorde da Morte", rank: "S", vidaMax: 4000, vidaAtual: 4000,
                        danoFisico: 200, danoMagico: 150, xpGanho: 5000, fugaPct: 0,
                        isBoss: true, isLordeDaMorte: true
                    };
                }

                const rankIndex = rankToIndex(rank);
                // Fallback para nome do monstro caso o rank não exista em MONSTRO_NOMES
            const nomesDisponiveis = MONSTRO_NOMES[rank] || [`Monstro Desconhecido Rank ${rank}`];
            const nome = randomChoice(nomesDisponiveis);

                let vidaBase = 0;
                let danoBase = 0;

                // Usar os stats customizados se existirem para o rank
                if (customMonsterStats[rank]) {
                    vidaBase = customMonsterStats[rank].vida;
                    danoBase = customMonsterStats[rank].dano;
                } else {
                    // Fallback para o cálculo original se o rank não estiver nos customMonsterStats
                    vidaBase = Math.floor(50 * Math.pow(1.9, rankIndex) + randomInt(0, 20 * Math.pow(1.6, rankIndex)));
                    const baseDanoFisicoRankE = 8;
                    danoBase = Math.floor(baseDanoFisicoRankE * Math.pow(1.85, rankIndex));
                }

                const vidaMax = vidaBase + randomInt(0, Math.floor(vidaBase * 0.15)); // Pequena variação na vida
                const danoFisico = danoBase + randomInt(0, Math.floor(danoBase * 0.1)); // Pequena variação no dano
                const danoMagico = Math.max(0, Math.floor(danoFisico * 0.5)); // Dano mágico é 50% do físico, com mínimo de 0

                const baseXpRankE = 10;
                const xpGanho = (rank === "E") ? baseXpRankE : Math.floor(baseXpRankE * Math.pow(2.3, rankIndex));
                const fugaPct = clamp(0.67 - 0.07 * rankIndex, 0.05, 0.67);

                return { nome, rank, vidaMax, vidaAtual: vidaMax, danoFisico, danoMagico, xpGanho, fugaPct, isBoss: false, isLordeDaMorte: false };
            }

            function gerarMonstroMasmorra(monsterRank) {
                const monstro = gerarMonstro(monsterRank);
                monstro.xpGanho = Math.floor(monstro.xpGanho * 1.1);
                return monstro;
            }
            function gerarMonarcaAleatorio() {
                const monarchKeys = Object.keys(MONARCH_BOSS_STATS);
                if (monarchKeys.length === 0) return null;
                const chosenKey = randomChoice(monarchKeys);
                const monarchData = MONARCH_BOSS_STATS[chosenKey];

                return {
                    nome: monarchData.nomeDisplay,
                    rank: monarchData.rank,
                    vidaMax: monarchData.vida,
                    vidaAtual: monarchData.vida,
                    danoFisico: monarchData.dano,
                    danoMagico: Math.floor(monarchData.dano * 0.3),
                    xpGanho: monarchData.xp,
                    fugaPct: 0,
                    isBoss: true,
                    isMonarchBoss: true,
                    portrait: monarchData.portrait || `https://via.placeholder.com/48?text=${chosenKey.substring(0, 1)}M`
                };
            }
            function gerarBossMasmorra(dungeonTypeRank, actualBossRank) {
                const dungeonConfig = DUNGEON_CONFIG[dungeonTypeRank];

                // --- NEW: Arquiteto Spawn Logic for Rank D Dungeons ---
                if (dungeonTypeRank === "D" && dungeonConfig.arquitetoChance && Math.random() < dungeonConfig.arquitetoChance) {
                    if (!game.player.isMarcado) {
                        game.batalha.pendingArquitetoEncounter = true;
                        return { ...ARQUITETO_STATS, vidaAtual: ARQUITETO_STATS.vidaMax }; // Ensure vidaAtual is set
                    }
                }
                // --- END NEW Arquiteto Logic ---

                if (dungeonConfig && dungeonConfig.lordeDaMorteChance &&
                    !game.player.classe &&
                    game.player.nivel >= 20 && rankToIndex(game.player.rank) >= rankToIndex("B") &&
                    !game.player.metLordeDaMorte &&
                    Math.random() < dungeonConfig.lordeDaMorteChance) {
                    game.player.metLordeDaMorte = true;
                    return gerarMonstro(null, true); // This already sets vidaAtual
                }

                const config = DUNGEON_CONFIG[dungeonTypeRank];
                if (!config || !config.bossBaseStats) {
                    console.error(`Configuração de bossBaseStats não encontrada para dungeon rank ${dungeonTypeRank}`);
                    const fallbackBossRank = actualBossRank || "C";
                    const fallbackStats = DUNGEON_CONFIG["E"].bossBaseStats;
                    const fbMon = gerarMonstro(fallbackBossRank);
                    return { ...fbMon, nome: `Boss ${fallbackBossRank} Desconhecido`, isBoss: true, vidaMax: fallbackStats.vidaMin, vidaAtual: fallbackStats.vidaMin, danoFisico: fallbackStats.danoMin, danoMagico: Math.floor(fallbackStats.danoMin * 0.3), xpGanho: fallbackStats.xpMin };
                }
                const baseStats = config.bossBaseStats;
                const nome = randomChoice(MONSTRO_NOMES[actualBossRank] || [`Boss ${actualBossRank}`]);
                const vidaMax = randomInt(baseStats.vidaMin, baseStats.vidaMax);
                const danoFisico = randomInt(baseStats.danoMin, baseStats.danoMax);
                const danoMagico = Math.floor(danoFisico * randomInt(30, 70) / 100);
                const xpGanho = randomInt(baseStats.xpMin, baseStats.xpMax);
                return { nome: `${nome} (Boss da Masmorra)`, rank: actualBossRank, vidaMax, vidaAtual: vidaMax, danoFisico, danoMagico, xpGanho, fugaPct: 0, isBoss: true };
            }

            const ITEM_PREFIXOS = {
                E: ["Simples", "Rústico", "Comum", "Velho", "Frágil"], D: ["Robusto", "Resistente", "Forte", "Ágil", "Místico"], C: ["Encantado", "Sagrado", "Veloz", "Poderoso", "Duradouro"],
                B: ["Épico", "Lendário", "Mágico", "Imponente", "Vibrante"], A: ["Divino", "Celestial", "Supremo", "Inquebrável", "Radiante"], S: ["Ancestral", "Mítico", "Eterno", "Soberano", "Infinito"],
            };

            const SLOT_EQUIPAVEL = ["Capacete", "Peitoral", "Calça", "Botas", "Arma", "Escudo", "Anel", "Colar"];
            const SUBTIPOS_ARMA = Object.keys(TIPOS_DE_ARMAS).filter(tipo => tipo !== "Nenhuma");


            function gerarItem(rank) {
                const tipoBase = Math.random() < 0.8 ? randomChoice(SLOT_EQUIPAVEL) : "Poção";
                let tipoFinal = tipoBase;
                let subTipoArma = null;

                if (tipoBase === "Arma") {
                    subTipoArma = randomChoice(SUBTIPOS_ARMA);
                }
                if (tipoBase === "Poção") {
                    const tipoPocao = Math.random() < 0.5 ? "drop" : "compra";
                    const pocaoBase = POTIONS[tipoPocao];
                    return { id: pocaoBase.id, nome: pocaoBase.nome, tipo: "Poção", rank: rank, efeitos: {}, preco: tipoPocao === "compra" ? 50 : (ITEM_BASE_PRICE[rank] || 10), curaVidaPct: pocaoBase.curaVidaPct, curaManaPct: pocaoBase.curaManaPct, descricao: pocaoBase.descricao, isPotion: true };
                }
                const prefixo = randomChoice(ITEM_PREFIXOS[rank]);
                let nome;
                if (subTipoArma) {
                    nome = `${randomChoice(ITEM_PREFIXOS[rank])} ${TIPOS_DE_ARMAS[subTipoArma].nomeDisplay}`;
                } else if (tipoFinal !== "Poção") {
                    nome = `${randomChoice(ITEM_PREFIXOS[rank])} ${tipoFinal}`;
                } else {
                    // Should not happen for this branch, but good practice.
                }
                const efeitos = {};
                const { min, max } = ITEM_ATRIBUTOS_POR_RANK[rank];
                const pontos = randomInt(min, max);

                switch (tipoFinal) {
                    case "Capacete": efeitos.percepcao = pontos; efeitos.resistencia = randomInt(Math.floor(min / 3), Math.floor(max / 3)); break;
                    case "Peitoral": efeitos.resistencia = pontos; efeitos.vitalidade = randomInt(Math.floor(min / 2), Math.floor(max / 2)); break;
                    case "Calça": efeitos.vitalidade = pontos; efeitos.agilidade = randomInt(Math.floor(min / 3), Math.floor(max / 3)); break;
                    case "Botas": efeitos.agilidade = pontos; break;
                    case "Arma":
                        efeitos.forca = pontos;
                        if (subTipoArma === "Arco" || subTipoArma === "Besta") efeitos.percepcao = Math.floor(pontos / 3);
                        if (subTipoArma === "Manoplas") efeitos.agilidade = Math.floor(pontos / 4);
                        break;
                    case "Escudo": efeitos.resistencia = pontos + randomInt(1, 3); break;
                    case "Anel": efeitos.inteligencia = pontos; break;
                    case "Colar": efeitos.agilidade = randomInt(Math.floor(min / 2), Math.floor(max / 2)); efeitos.percepcao = randomInt(Math.floor(min / 2), Math.floor(max / 2)); break;
                }
                const preco = ITEM_BASE_PRICE[rank] * (1 + Math.random() * 0.5 + rankToIndex(rank) * 0.1);
                return { id: crypto.randomUUID(), nome, tipo: tipoFinal, subTipoArma: subTipoArma, rank, efeitos, preco: Math.floor(preco), isPotion: false };
            }

            function itemsAreIdentical(item1, item2) {
                if (item1.isPotion && item2.isPotion) return item1.id === item2.id;
                if (!item1.isPotion && !item2.isPotion) {
                    if (item1.nome !== item2.nome || item1.tipo !== item2.tipo || item1.rank !== item2.rank) return false;
                    const effects1 = item1.efeitos || {}; const effects2 = item2.efeitos || {};
                    const keys1 = Object.keys(effects1).sort(); const keys2 = Object.keys(effects2).sort();
                    if (keys1.length !== keys2.length) return false;
                    for (let i = 0; i < keys1.length; i++) {
                        if (keys1[i] !== keys2[i] || effects1[keys1[i]] !== effects2[keys2[i]]) return false;
                    }
                    return true;
                }
                return false;
            }

            function addItemToInventory(itemToAdd) {
                let foundStack = false;
                for (let invItem of game.player.inventario) {
                    if (itemsAreIdentical(invItem, itemToAdd)) {
                        invItem.quantity = (invItem.quantity || 1) + 1; foundStack = true; break;
                    }
                }
                if (!foundStack) game.player.inventario.push({ ...itemToAdd, quantity: 1 });
            }

            function atualizarRank() {
                const total = Object.values(game.player.atributos).reduce((a, b) => a + b, 0);
                let novoRank = "E";
                for (let i = RANKS.length - 1; i >= 0; i--) {
                    if (total >= RANK_MIN_TOTAL[RANKS[i]]) { novoRank = RANKS[i]; break; }
                }
                if (novoRank !== game.player.rank) {
                    game.player.rank = novoRank;
                }
            }

            function atualizarAtributosDerivados() {
                const a = game.player.atributos;
                let tempForca = a.forca, tempAgilidade = a.agilidade, tempInteligencia = a.inteligencia,
                    tempResistencia = a.resistencia, tempVitalidade = a.vitalidade, tempPercepcao = a.percepcao;

                for (const equipSlot in game.player.equipamento) {
                    const equip = game.player.equipamento[equipSlot];
                    if (equip && equip.efeitos) {
                        for (const [attr, val] of Object.entries(equip.efeitos)) {
                            switch (attr) {
                                case 'forca': tempForca += val; break; case 'agilidade': tempAgilidade += val; break;
                                case 'inteligencia': tempInteligencia += val; break; case 'resistencia': tempResistencia += val; break;
                                case 'vitalidade': tempVitalidade += val; break; case 'percepcao': tempPercepcao += val; break;
                            }
                        }
                    }
                }

                const vitalidadeBonusVida = tempVitalidade * 5;
                game.player.vidaMax = Math.floor(BASE_HP + vitalidadeBonusVida);
                game.player.vidaAtual = Math.min(game.player.vidaAtual, game.player.vidaMax);
                game.player.vitalidadeBonusVida = vitalidadeBonusVida;
                game.player.maxActiveShadows = 1 + Math.min(4, Math.floor(tempInteligencia / 15));
                game.player.recipienteCapacity = 10 + (Math.floor(tempInteligencia / 15) * 5);
                const inteligenciaBonusMana = tempInteligencia * 10;
                game.player.manaMax = Math.floor(BASE_MANA + inteligenciaBonusMana);
                game.player.manaAtual = Math.min(game.player.manaAtual, game.player.manaMax);
                game.player.inteligenciaBonusMana = inteligenciaBonusMana;

                const forcaBonusDano = tempForca * 2.0; // Changed from 0.5 to 2.0
                game.player.currentDanoFisico = BASE_DANO_FISICO + forcaBonusDano;

                const resistenciaBonusPct = tempResistencia * 0.1;
                game.player.currentReducaoDano = resistenciaBonusPct;
                game.player.resistenciaPct = resistenciaBonusPct / 100;

                const agilidadeBonusFuga = tempAgilidade * 0.0005;
                game.player.currentChanceFuga = agilidadeBonusFuga * 100;
                game.player.agilidadePctFuga = agilidadeBonusFuga;

                const percepcaoBonusEsquiva = tempPercepcao * 0.0005;
                game.player.currentChanceEsquiva = percepcaoBonusEsquiva * 100;
                game.player.percepcaoPct = percepcaoBonusEsquiva;

                const inteligenciaBonusDanoMagico = tempInteligencia * 2.0;
                game.player.currentDanoMagico = BASE_DANO_MAGICO + inteligenciaBonusDanoMagico;

                aplicarEfeitosEquipamento();
                aplicarBuffs();
            }

            function aplicarBuffs() {
                const gritoBuff = game.player.activeBuffs.find(b => b.id === "g_grito_guerra");
                if (gritoBuff) {
                    game.player.currentDanoFisico *= (1 + gritoBuff.valor);
                }
                const escudoSantoBuff = game.player.activeBuffs.find(b => b.id === "p_escudo_santo");
                if (escudoSantoBuff) {
                    game.player.currentReducaoDano += (escudoSantoBuff.valor * 100);
                    game.player.resistenciaPct = game.player.currentReducaoDano / 100;
                }
                const dominioBuff = game.player.activeBuffs.find(b => b.id === "n_dominio_sombras");
                if (dominioBuff && game.player.sombraAtiva && game.player.sombraAtiva.statsAtuais) {
                    game.player.sombraAtiva.statsAtuais.danoBase = Math.floor(game.player.sombraAtiva.statsAtuais.danoBase * (1 + dominioBuff.valor));
                }
            }

            function decrementarBuffs() {
                if (!game.batalha.emBatalha && !(game.dungeon.active && !game.batalha.monstro)) return;
                let buffsChanged = false;
                game.player.activeBuffs = game.player.activeBuffs.filter(buff => {
                    buff.duracao--;
                    if (buff.duracao <= 0) {
                        mostrarMensagem(`O efeito de <span class="font-bold text-amber-400">${buff.nomeSkill || 'buff'}</span> terminou.`);
                        buffsChanged = true;
                        return false;
                    }
                    return true;
                });
                if (buffsChanged) {
                    atualizarAtributosDerivados();
                    atualizarStatusAtributos();
                }
            }

            function calcularDanoFisico() { return Math.floor(game.player.currentDanoFisico); }
            function calcularDanoMagico(skill) { return Math.floor((skill.danoBase || 0) + game.player.currentDanoMagico); }
            function calcularDanoRecebido(dano) { return Math.max(1, Math.floor(dano * (1 - game.player.resistenciaPct))); }

            function calcularChanceFuga(monstro) {
                if (monstro.isBoss) return 0;
                const rankIndex = rankToIndex(monstro.rank);
                const baseFuga = clamp(0.67 - (FUGIR_PCT_DECREMENTO * rankIndex), 0.05, 0.67);
                return clamp(baseFuga + game.player.agilidadePctFuga, 0, 1);
            }
            function calcularGastoManaParaBoss(skill, boss) {
                let custoBase;
                if (skill.manaCostPercent !== undefined) {
                    custoBase = boss.manaMax * skill.manaCostPercent;
                } else if (skill.manaBase !== undefined) {
                    custoBase = skill.manaBase;
                } else if (skill.custoMana !== undefined) {
                    custoBase = skill.custoMana;
                } else {
                    custoBase = Math.floor(boss.manaMax * 0.1);
                }
                return Math.max(1, Math.floor(custoBase));
            }

            function calcularGastoMana(skill) {
                let custoBase;
                if (skill.manaCostPercent !== undefined) {
                    custoBase = game.player.manaMax * skill.manaCostPercent;
                } else if (skill.manaBase !== undefined) {
                    custoBase = skill.manaBase;
                } else {
                    const pctCusto = MANA_GASTO_PCT[skill.rank] || 0.1;
                    custoBase = game.player.manaMax * pctCusto;
                }
                return Math.max(1, Math.floor(custoBase * (1 - game.player.refinoMagicoPct)));
            }

            function atualizarStatusAtributos() {
                document.getElementById("status-nivel").textContent = game.player.nivel;
                document.getElementById("status-rank").textContent = game.player.rank;

                // --- MODIFIED BLOCK FOR CLASS NAME ---
                let classeNome = "Nenhuma";
                let classeTitle = "Nenhuma"; // For the tooltip
                if (game.player.classe) {
                    if (game.player.classe === "Necromante" && game.player.isMarcado) {
                        classeNome = "Monarca das Sombras";
                        classeTitle = "Monarca das Sombras (Marcado)"; // More descriptive title
                    } else {
                        classeNome = CLASSES_DATA[game.player.classe]?.nomeDisplay || game.player.classe;
                        classeTitle = classeNome;
                        if (game.player.isMarcado) { // If Marcado but not Necromancer Monarch
                            classeTitle += " (Marcado)";
                        }
                    }
                } else if (game.player.isMarcado) { // Marcado but no class yet
                    classeTitle = "Marcado";
                }
                // --- END MODIFIED BLOCK ---

                const classeElement = document.getElementById("status-classe");
                classeElement.textContent = classeNome;
                classeElement.title = classeTitle; // Use the potentially more descriptive title

                document.getElementById("status-moedas").textContent = game.player.moedas;
                document.getElementById("status-xp").textContent = game.player.xp;
                document.getElementById("status-xpProximo").textContent = game.player.xpProximoNivel;
                const xpBar = document.getElementById("status-xp-bar");
                if (xpBar) xpBar.style.width = getBarPercentage(game.player.xp, game.player.xpProximoNivel);
                document.getElementById("status-vida").textContent = `${game.player.vidaAtual} / ${game.player.vidaMax}`;
                const vidaBar = document.getElementById("status-vida-bar");
                if (vidaBar) vidaBar.style.width = getBarPercentage(game.player.vidaAtual, game.player.vidaMax);
                document.getElementById("bonus-vida-max-val").textContent = game.player.vitalidadeBonusVida.toFixed(0);
                document.getElementById("status-mana").textContent = `${game.player.manaAtual} / ${game.player.manaMax}`;
                const manaBar = document.getElementById("status-mana-bar");
                if (manaBar) manaBar.style.width = getBarPercentage(game.player.manaAtual, game.player.manaMax);
                document.getElementById("bonus-mana-max-val").textContent = game.player.inteligenciaBonusMana.toFixed(0);
                document.getElementById("bonus-dano-fisico").textContent = game.player.currentDanoFisico.toFixed(1);
                document.getElementById("bonus-dano-magico").textContent = game.player.currentDanoMagico.toFixed(1);
                document.getElementById("bonus-resistencia").textContent = (game.player.currentReducaoDano).toFixed(2);
                document.getElementById("bonus-fuga").textContent = (game.player.currentChanceFuga).toFixed(2);
                document.getElementById("bonus-esquiva").textContent = (game.player.currentChanceEsquiva).toFixed(2);
            }
            function mostrarMensagem(html) {
                const storyText = document.getElementById("story-text");
                if (storyText) storyText.innerHTML = html;
            }

            function limparEscolhas() {
                const choices = document.getElementById("choices");
                if (choices) choices.innerHTML = "";

                const battleSubmenu = document.getElementById("battle-submenu-choices");
                if (battleSubmenu) {
                    battleSubmenu.innerHTML = "";
                    battleSubmenu.classList.add("hidden");
                }
                if (game.batalha.emBatalha) {
                    document.getElementById("battle-main-commands")?.classList.remove("hidden");
                }
            }


            function adicionarEscolha(texto, callback, disabled = false, title = null, context = "main") {
                let choicesContainer;
                if (game.batalha.emBatalha && context === "submenu") {
                    choicesContainer = document.getElementById("battle-submenu-choices");
                    choicesContainer.classList.remove("hidden");
                    document.getElementById("battle-main-commands").classList.add("hidden");
                } else {
                    choicesContainer = document.getElementById("choices");
                }

                if (!choicesContainer) return;
                const btn = document.createElement("button");
                if (disabled) {
                    btn.className = "bg-slate-500 rounded px-4 py-2 font-semibold cursor-default text-slate-400";
                    btn.disabled = true;
                } else {
                    btn.className = "bg-slate-600 hover:bg-slate-500 rounded px-4 py-2 font-semibold focus:outline-none focus:ring-2 focus:ring-slate-400";
                }
                btn.innerHTML = texto;
                if (title) btn.title = title;
                if (callback && !disabled) {
                    btn.addEventListener("click", () => {
                        if (!(game.batalha.emBatalha && context === "submenu")) {
                            limparEscolhas();
                        }
                        callback();
                    });
                }
                choicesContainer.appendChild(btn);
            }


            function toggleHeaderNavButtons(disable) {
                const btnIds = ["btn-inicio", "btn-atributos", "btn-skills", "btn-inventario", "btn-sair"];
                btnIds.forEach(id => {
                    const button = document.getElementById(id);
                    if (button) button.disabled = disable;
                });
                updateGoogleSignInUI();
            }

            function toggleChatInput(disable) {
                const chatInput = document.getElementById('chat-command-input');
                const sendButton = document.getElementById('btn-send-command');
                if (chatInput) chatInput.disabled = disable;
                if (sendButton) sendButton.disabled = disable;
            }

            function parseJwt(token) {
                try {
                    const base64Url = token.split('.')[1];
                    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                    const jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                    return JSON.parse(jsonPayload);
                } catch (e) { console.error("Error parsing JWT: ", e); return null; }
            }

            function updateGoogleSignInUI() {
                const signInButtonContainer = document.getElementById('google-signin-button-container');
                const signOutButton = document.getElementById('btn-signout-google');
                const saveButton = document.getElementById('btn-save-google');
                const greetingSpan = document.getElementById('google-user-greeting');

                const criticalGameState = game.batalha.emBatalha ||
                    (game.dungeon && game.dungeon.isBossRoomConfirmation) ||
                    game.estado === 'gameover' ||
                    game.estado === 'batalha' ||
                    game.estado === 'classeAtribuida' ||
                    game.estado === 'necromancerUnlock';

                if (isGoogleSignedIn && googleDecodedCredential) {
                    if (signInButtonContainer) signInButtonContainer.style.display = 'none';
                    if (signOutButton) signOutButton.classList.remove('hidden');
                    if (signOutButton) signOutButton.disabled = criticalGameState;
                    if (greetingSpan) greetingSpan.textContent = `Olá, ${googleDecodedCredential.given_name || googleDecodedCredential.name || ''}!`;
                    if (greetingSpan) greetingSpan.classList.remove('hidden');

                    if (criticalGameState) {
                        if (saveButton) saveButton.classList.add('hidden');
                        if (saveButton) saveButton.disabled = true;
                    } else {
                        if (saveButton) saveButton.classList.remove('hidden');
                        if (saveButton) saveButton.disabled = false;
                    }
                } else {
                    if (signInButtonContainer) signInButtonContainer.style.display = 'block';
                    if (signOutButton) signOutButton.classList.add('hidden');
                    if (saveButton) saveButton.classList.add('hidden');
                    if (greetingSpan) greetingSpan.classList.add('hidden');
                    if (greetingSpan) greetingSpan.textContent = '';
                }
            }

            window.handleGoogleCredentialResponse = function (response) {
                googleDecodedCredential = parseJwt(response.credential);
                if (googleDecodedCredential) {
                    isGoogleSignedIn = true;
                    const gameLoaded = loadGameFromGoogle();
                    if (gameLoaded) {
                        setTimeout(() => mostrarMensagem(`Bem-vindo(a) de volta, ${googleDecodedCredential.given_name || googleDecodedCredential.name}! Seu progresso foi carregado.`), 50);
                    } else {
                        setTimeout(() => mostrarMensagem(`Bem-vindo(a), ${googleDecodedCredential.given_name || googleDecodedCredential.name}! Nenhum progresso salvo encontrado. Iniciando novo jogo.`), 50);
                    }
                } else {
                    isGoogleSignedIn = false;
                    console.error("Falha ao decodificar credencial do Google.");
                }
                updateGoogleSignInUI();
            }

            function initializeGoogleSignInRelatedElements() {
                if (typeof google !== 'undefined' && google.accounts && google.accounts.id) {
                    google.accounts.id.initialize({
                        client_id: GOOGLE_CLIENT_ID,
                        callback: handleGoogleCredentialResponse
                    });

                    google.accounts.id.renderButton(
                        document.getElementById("g_id_signin_button_div"),
                        { type: "standard", theme: "filled_black", size: "large", text: "signin_with", shape: "rectangular", logo_alignment: "left" }
                    );
                }

                if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === "YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com") {
                    console.warn("Google Client ID não está configurado. O login com Google não funcionará.");
                    const signInContainer = document.getElementById('google-signin-button-container');
                    if (signInContainer) signInContainer.innerHTML = '<p class="text-xs text-red-500 py-2">Login Google não configurado.</p>';
                    const saveBtn = document.getElementById('btn-save-google');
                    if (saveBtn) saveBtn.style.display = 'none';
                    const signOutBtn = document.getElementById('btn-signout-google');
                    if (signOutBtn) signOutBtn.style.display = 'none';
                    return;
                }

                const saveButton = document.getElementById('btn-save-google');
                if (saveButton) saveButton.addEventListener('click', saveGameToGoogle);

                const signOutButton = document.getElementById('btn-signout-google');
                if (signOutButton) signOutButton.addEventListener('click', handleGoogleSignOut);

                updateGoogleSignInUI();
            }

            function handleGoogleSignOut() {
                const userIdToRevoke = googleDecodedCredential ? googleDecodedCredential.sub : null;
                googleDecodedCredential = null;
                isGoogleSignedIn = false;

                if (typeof google !== 'undefined' && google.accounts && google.accounts.id) {
                    if (userIdToRevoke) {
                        google.accounts.id.revoke(userIdToRevoke, done => {
                        });
                    }
                    google.accounts.id.disableAutoSelect();
                }
                updateGoogleSignInUI();
                mostrarMensagem("Você saiu da sua conta Google. O progresso não salvo ou não carregado pode ser perdido ao recarregar.<br/>Recarregando para um novo estado de jogo em alguns segundos...");
                setTimeout(() => {
                    iniciarJogo(true);
                }, 3000);
            }

            function saveGameToGoogle() {
                if (!isGoogleSignedIn || !googleDecodedCredential) {
                    alert("Você precisa estar logado com o Google para salvar o progresso."); return;
                }
                try {
                    const userId = googleDecodedCredential.sub;
                    const playerDataToSave = JSON.parse(JSON.stringify(game.player));
                    localStorage.setItem(GOOGLE_SAVE_KEY_PREFIX + userId, JSON.stringify(playerDataToSave));
                    mostrarMensagem(`Progresso salvo na sua conta Google (${googleDecodedCredential.email || 'usuário'})!`);
                    setTimeout(() => {
                        if (game.estado === 'inicio' && !game.batalha.emBatalha) {
                        }
                    }, 2000);
                } catch (error) {
                    console.error("Erro ao salvar o jogo: ", error);
                    alert("Ocorreu um erro ao tentar salvar seu progresso.");
                }
            }

            function loadGameFromGoogle() {
                if (!isGoogleSignedIn || !googleDecodedCredential) return false;
                try {
                    const userId = googleDecodedCredential.sub;
                    const savedDataString = localStorage.getItem(GOOGLE_SAVE_KEY_PREFIX + userId);
                    if (savedDataString) {
                        const loadedPlayer = JSON.parse(savedDataString);
                        const defaultPlayerState = createNewPlayerState();

                        game.player = {
                            ...defaultPlayerState,
                            ...loadedPlayer,
                            atributos: { ...defaultPlayerState.atributos, ...(loadedPlayer.atributos || {}) },
                            equipamento: { ...defaultPlayerState.equipamento, ...(loadedPlayer.equipamento || {}) },
                            inventario: loadedPlayer.inventario || [],
                            magiasAdquiridas: loadedPlayer.magiasAdquiridas || [],
                            magiasEquipadas: loadedPlayer.magiasEquipadas || [],
                            activeBuffs: loadedPlayer.activeBuffs || [],
                            recipienteSombras: loadedPlayer.recipienteSombras || [],
                            sombraAtiva: loadedPlayer.sombraAtiva || null,
                            lastDefeatedMonsterInfo: loadedPlayer.lastDefeatedMonsterInfo || null,
                            metLordeDaMorte: loadedPlayer.metLordeDaMorte || false,
                            vitalidadeBonusVida: loadedPlayer.vitalidadeBonusVida || 0,
                            inteligenciaBonusMana: loadedPlayer.inteligenciaBonusMana || 0
                        };

                        atualizarAtributosDerivados();
                        game.player.vidaAtual = Math.min(game.player.vidaAtual, game.player.vidaMax);
                        game.player.manaAtual = Math.min(game.player.manaAtual, game.player.manaMax);

                        atualizarRank();
                        atualizarStatusAtributos();
                        atualizarInventarioTela();
                        atualizarSkillsTela();
                        atualizarMercadorVisibilidade();
                        abrirInicio();
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error("Erro ao carregar o jogo: ", error);
                    alert("Ocorreu um erro ao tentar carregar seu progresso. Iniciando um novo jogo.");
                    iniciarJogo(true);
                    return false;
                }
            }


            function deleteSavedGameForGoogleUser() {
                if (!isGoogleSignedIn || !googleDecodedCredential) return;
                try {
                    const userId = googleDecodedCredential.sub;
                    localStorage.removeItem(GOOGLE_SAVE_KEY_PREFIX + userId);
                } catch (error) { console.error("Erro ao deletar o jogo salvo: ", error); }
            }

            function createNewPlayerState() {
                return {
                    nome: "Herói", classe: null, nivel: 1, xp: 0, xpProximoNivel: 100, rank: "E",
                    atributos: { ...BASE_STATS }, pontosDistribuir: 10,
                    vidaMax: BASE_HP, vidaAtual: BASE_HP, manaMax: BASE_MANA, manaAtual: BASE_MANA,
                    danoFisicoBase: BASE_DANO_FISICO, danoMagicoBase: BASE_DANO_MAGICO,
                    resistenciaPct: BASE_RESISTENCIA, refinoMagicoPct: 0, percepcaoPct: 0,
                    agilidadePctFuga: 0,
                    vitalidadeBonusVida: 0,
                    inteligenciaBonusMana: 0,
                    isMarcado: false,
                    isMonarcaDasSombras: false,
                    inventario: [],
                    equipamento: { capacete: null, peitoral: null, calca: null, botas: null, arma: null, escudo: null, anel: null, colar: null },
                    moedas: 100, rodadas: 0, xpBonus: XP_BONUS_GLOBAL,
                    magiasAdquiridas: [], magiasEquipadas: [], currentArea: "E",
                    currentDanoFisico: BASE_DANO_FISICO, currentReducaoDano: BASE_RESISTENCIA,
                    currentChanceFuga: 0, currentChanceEsquiva: 0, currentDanoMagico: BASE_DANO_MAGICO,
                    activeBuffs: [],
                    recipienteSombras: [], sombraAtiva: null, lastDefeatedMonsterInfo: null, metLordeDaMorte: false, maxActiveShadows: 1, recipienteCapacity: 10,
                };
            }

            function iniciarJogo(forceReset = false) {
                if (forceReset) {
                    game.player = createNewPlayerState();
                    game.dungeon = { active: false, name: "", typeRank: "E", totalRooms: 0, currentRoom: 0, monsterRankForRooms: "D", bossRankForDungeon: "C", bossDefeated: false, isBossRoomConfirmation: false };
                    game.batalha = { emBatalha: false, monstro: null, turnoJogador: true, danoRecebido: 0, isBossBattle: false, jogadorAgiuNoTurno: false, };
                    game.estado = "inicio"; game.monstroAtual = null;
                } else if (!isGoogleSignedIn || !loadGameFromGoogle()) {
                    game.player = createNewPlayerState();
                    game.dungeon = { active: false, name: "", typeRank: "E", totalRooms: 0, currentRoom: 0, monsterRankForRooms: "D", bossRankForDungeon: "C", bossDefeated: false, isBossRoomConfirmation: false };
                    game.batalha = { emBatalha: false, monstro: null, turnoJogador: true, danoRecebido: 0, isBossBattle: false, jogadorAgiuNoTurno: false, };
                    game.estado = "inicio"; game.monstroAtual = null;
                }

                toggleHeaderNavButtons(false);
                toggleChatInput(false);
                atualizarAtributosDerivados();
                atualizarRank();
                atualizarStatusAtributos();
                atualizarMercadorVisibilidade();
                atualizarRecipienteSombrasTela();

                if (!atribuirClasseAleatoriaSeNecessario() && game.estado !== "necromancerUnlock" && game.estado !== "classeAtribuida") {
                    abrirInicio();
                }
                updateGoogleSignInUI();
            }

            window.onload = () => {
                initializeGoogleSignInRelatedElements();
                iniciarJogo();
                document.getElementById("atributos-screen")?.addEventListener("click", manipularBotaoAtributo);
                document.getElementById("btn-salvar-atributos")?.addEventListener("click", salvarAtributos);
                document.getElementById("btn-comprar-mercador")?.addEventListener("click", comprarItensMercador);

                // NOVO: Inicializa o modo de adição de atributos
                const attributeModeButtons = document.querySelectorAll('.attribute-mode-btn');
                attributeModeButtons.forEach(btn => {
                    btn.addEventListener('click', manipularBotaoAtributo); // Usa o mesmo manipulador
                });
                // Define o modo +1 como ativo por padrão no início
                const defaultModeButton = document.querySelector('.attribute-mode-btn[data-amount="1"]');
                if (defaultModeButton) {
                    defaultModeButton.classList.add('active');
                }

                document.getElementById("btn-battle-fight")?.addEventListener("click", () => {
                    if (game.batalha.emBatalha && game.batalha.turnoJogador && !game.batalha.jogadorAgiuNoTurno) {
                        mostrarHabilidadesArma();
                    } else if (game.batalha.jogadorAgiuNoTurno) {
                        mostrarMensagem("Você já agiu neste turno.");
                    }
                });
                document.getElementById("btn-battle-skill")?.addEventListener("click", () => {
                    if (game.batalha.emBatalha && game.batalha.turnoJogador) {
                        usarMagiaMenu();
                    }
                });
                document.getElementById("btn-battle-item")?.addEventListener("click", () => {
                    if (game.batalha.emBatalha && game.batalha.turnoJogador) {
                        usarPocaoMenu();
                    }
                });
                document.getElementById("btn-battle-escape")?.addEventListener("click", () => {
                    if (game.batalha.emBatalha && game.batalha.turnoJogador && !(game.batalha.monstro.isBoss)) {
                        tentarFugir();
                    } else if (game.batalha.monstro.isBoss) {
                        mostrarMensagem("Não é possível fugir de um chefe!");
                    }
                });
            };

            function atualizarMercadorVisibilidade() {
                const mercadorBtn = document.getElementById("btn-mercador");
                if (!mercadorBtn) return;
                if (game.player.nivel > 0 && game.player.nivel % 5 === 0 && !game.batalha.emBatalha && !game.dungeon.active) {
                    mercadorBtn.classList.remove("hidden");
                } else {
                    mercadorBtn.classList.add("hidden");
                }
            }

            function explorarArea() {
                game.player.rodadas++;
                game.player.lastDefeatedMonsterInfo = null;
                const evento = Math.random();
                if (rankToIndex(game.player.currentArea) >= rankToIndex("B") && Math.random() < 0.05) {
                    const monarchBoss = gerarMonarcaAleatorio();
                    if (monarchBoss) {
                        game.monstroAtual = monarchBoss;
                        mostrarMensagem(`Um arrepio percorre sua espinha! Das profundezas de Arkham, surge o <span class="font-bold text-red-500">${monarchBoss.nome}</span>!`);
                        setTimeout(() => iniciarBatalha(monarchBoss), 2000);
                        updateGoogleSignInUI();
                        return;
                    }
                }
                if (evento < 0.7) {
                    const currentAreaRankIndex = rankToIndex(game.player.currentArea);
                    const rankForMonsters = [RANKS[currentAreaRankIndex]];
                    if (currentAreaRankIndex + 1 < RANKS.length && Math.random() < 0.3) {
                        rankForMonsters.push(RANKS[currentAreaRankIndex + 1]);
                    }
                    const chosenRankForMonster = randomChoice(rankForMonsters);
                    const monstro = gerarMonstro(chosenRankForMonster);
                    game.monstroAtual = monstro;
                    iniciarBatalha(monstro);
                } else {
                    mostrarMensagem(`Você explora os <span class="font-bold text-sky-400">${DUNGEON_CONFIG[game.player.currentArea].name}</span> e encontra um lugar tranquilo. O vento sopra suavemente e você aproveita para recuperar suas forças.<br/><br/>O que deseja fazer?`);
                    limparEscolhas();
                    adicionarEscolha("Continuar explorando", explorarArea);
                    adicionarEscolha(`Entrar na Masmorra (Rank ${game.player.currentArea})`, () => entrarMasmorra(game.player.currentArea));
                    adicionarEscolha("Ver atributos", abrirAtributos);
                    adicionarEscolha("Abrir habilidades", abrirSkills);
                    adicionarEscolha("Abrir inventário", abrirInventario);
                    if (game.player.nivel >= 10) adicionarEscolha("Mudar de Área", abrirTelaMudarArea);
                }
                atualizarStatusAtributos();
                updateGoogleSignInUI();
            }

            function abrirTelaMudarArea() {
                game.estado = "mudarAreaScreen";
                const playerRankIndex = rankToIndex(game.player.rank);
                let areaChoicesHtml = `Você está atualmente nos <span class="font-bold text-sky-400">${DUNGEON_CONFIG[game.player.currentArea].name}</span>.<br/><br/>Escolha uma nova área para viajar (Requer Nível 10+ e Rank apropriado):<br/>`;
                mostrarMensagem(areaChoicesHtml);
                limparEscolhas();

                RANKS.forEach(areaRank => {
                    const targetAreaRankIndex = rankToIndex(areaRank);
                    if (targetAreaRankIndex <= playerRankIndex) {
                        if (areaRank === game.player.currentArea) {
                            adicionarEscolha(`${DUNGEON_CONFIG[areaRank].name} (Atual)`, null, true);
                        } else {
                            adicionarEscolha(`Viajar para ${DUNGEON_CONFIG[areaRank].name}`, () => mudarDeArea(areaRank));
                        }
                    } else {
                        const choicesDiv = document.getElementById("choices");
                        if (!choicesDiv) return;
                        const btn = document.createElement("button");
                        btn.className = "bg-slate-700 rounded px-4 py-2 font-semibold text-slate-500 cursor-not-allowed";
                        btn.innerHTML = `${DUNGEON_CONFIG[areaRank].name} (Requer Rank ${areaRank})`;
                        btn.disabled = true;
                        choicesDiv.appendChild(btn);
                    }
                });
                adicionarEscolha("Voltar", abrirInicio);
                updateGoogleSignInUI();
            }

            function mudarDeArea(novaAreaRank) {
                game.player.currentArea = novaAreaRank;
                game.player.lastDefeatedMonsterInfo = null;
                mostrarMensagem(`Você viajou para os <span class="font-bold text-sky-400">${DUNGEON_CONFIG[novaAreaRank].name}</span>.<br/><br/>O que deseja fazer?`);
                limparEscolhas();
                adicionarEscolha("Explorar a área", explorarArea);
                adicionarEscolha(`Entrar na Masmorra (Rank ${novaAreaRank})`, () => entrarMasmorra(novaAreaRank));
                adicionarEscolha("Ver atributos", abrirAtributos);
                adicionarEscolha("Abrir habilidades", abrirSkills);
                adicionarEscolha("Abrir inventário", abrirInventario);
                if (game.player.nivel >= 10) adicionarEscolha("Mudar de Área", abrirTelaMudarArea);
                updateGoogleSignInUI();
            }

            function tentarDesbloquearNecromante(monstroDerrotado) {
                if (monstroDerrotado.isLordeDaMorte && !game.player.classe) {
                    game.estado = "necromancerUnlock";
                    toggleHeaderNavButtons(true);
                    toggleChatInput(true);

                    game.player.classe = "Necromante";
                    const classeInfo = CLASSES_DATA.Necromante;
                    let msg = `<span class="text-purple-400 font-bold text-xl">Destino Revelado!</span><br/>Ao derrotar o Lorde da Morte, você sente uma afinidade sombria despertar! Sua classe agora é <span class="font-bold text-purple-300">${classeInfo.nomeDisplay}</span>!`;

                    const skillExtracao = classeInfo.habilidades.find(h => h.id === "n_extracao_sombras");
                    const skillInvocar = classeInfo.habilidades.find(h => h.id === "n_invocar_sombra");

                    // Ensure skills are only added if not already acquired
                    if (skillExtracao && !game.player.magiasAdquiridas.includes(skillExtracao.id)) {
                        game.player.magiasAdquiridas.push(skillExtracao.id);
                        msg += `<br/>Você aprendeu: <span class="font-bold text-amber-400">${skillExtracao.nome}</span>.`;
                        if (game.player.magiasEquipadas.length < 4) {
                            game.player.magiasEquipadas.push(skillExtracao.id);
                            msg += ` Equipada automaticamente.`;
                        }
                    }
                    if (skillInvocar && !game.player.magiasAdquiridas.includes(skillInvocar.id)) {
                        game.player.magiasAdquiridas.push(skillInvocar.id);
                        msg += `<br/>Você aprendeu: <span class="font-bold text-amber-400">${skillInvocar.nome}</span>.`;
                        if (game.player.magiasEquipadas.length < 4 && !game.player.magiasEquipadas.includes(skillInvocar.id)) {
                            game.player.magiasEquipadas.push(skillInvocar.id);
                            msg += ` Equipada automaticamente.`;
                        }
                    }
                    // ... (rest of the function remains the same)
                }
                return false; // Return false as it's handled separately, not as a general skill unlock.
            }

            function atribuirClasseAleatoriaSeNecessario() {
                if (game.player.classe) return false;

                if (game.player.nivel >= 10 && rankToIndex(game.player.rank) >= rankToIndex("D")) {
                    game.estado = "classeAtribuida";
                    toggleHeaderNavButtons(true);
                    toggleChatInput(true);

                    const availableClasses = PLAYER_CLASSES_LIST.filter(c => c !== "Necromante");
                    if (availableClasses.length === 0) {
                        abrirInicio(); return false;
                    }
                    const classeAleatoria = randomChoice(availableClasses);
                    game.player.classe = classeAleatoria;
                    const classeEscolhida = CLASSES_DATA[classeAleatoria];
                    if (!classeEscolhida) {
                        abrirInicio(); return false;
                    }

                    let msg = `Ao atingir o Nível 10 e Rank D, o destino interveio!<br/>Sua classe agora é <span class="font-bold text-sky-400">${classeEscolhida.nomeDisplay}</span>!`;

                    if (classeEscolhida.habilidades && classeEscolhida.habilidades.length > 0) {
                        classeEscolhida.habilidades.forEach((skill, index) => { // Added index to skill for future use if needed
                            skill.indiceNaClasse = index; // Assign an index to the skill within its class
                            if (game.player.nivel >= skill.unlockLevel && !game.player.magiasAdquiridas.includes(skill.id)) {
                                const startingSkills = classeEscolhida.habilidades
                                    .filter(h => h.unlockLevel <= game.player.nivel)
                                    .sort((a, b) => a.unlockLevel - b.unlockLevel);
                                const isStartingSkill = startingSkills.length > 0 && startingSkills[0].id === skill.id;

                                if (isStartingSkill || skill.unlockLevel === 1) {
                                    game.player.magiasAdquiridas.push(skill.id);
                                    msg += `<br/>Você aprendeu: <span class="font-bold text-amber-400">${skill.nome}</span>.`;
                                    if (game.player.magiasEquipadas.length < 4) {
                                        game.player.magiasEquipadas.push(skill.id);
                                        msg += ` A habilidade foi equipada automaticamente.`;
                                    }
                                }
                            }
                        });
                    }
                    atualizarStatusAtributos();
                    atualizarSkillsTela();
                    mostrarMensagem(msg);
                    limparEscolhas();
                    adicionarEscolha("Entendido, continuar aventura!", () => {
                        abrirInicio();
                    });
                    updateGoogleSignInUI();
                    return true;
                }
                return false;
            }

            function iniciarBatalha(monstro) {
                game.batalha.jogadorAgiuNoTurno = false;
                habilitarBotoesAcaoBatalha();
                toggleHeaderNavButtons(true);
                toggleChatInput(true);
                game.estado = "batalha"; game.batalha.emBatalha = true; game.batalha.monstro = monstro;
                game.batalha.turnoJogador = true; game.batalha.isBossBattle = monstro.isBoss;

                decrementarBuffs();

                let msg = `Você encontrou: <span class="font-bold text-rose-400">${monstro.nome}</span> (Rank ${monstro.rank}).`;
                if (game.dungeon.active && !monstro.isBoss) {
                    msg = `Sala ${game.dungeon.currentRoom + 1}/${game.dungeon.totalRooms} d${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} <span class="font-bold text-violet-400">${game.dungeon.name}</span>.<br/>` + msg;

                } else if (monstro.isLordeDaMorte) {
                    msg = `<span class="text-purple-600 font-extrabold">PRESENÇA SOMBRIA!</span><br/>O <span class="font-bold text-purple-400">${monstro.nome}</span> surge!<br/>` + msg;
                } else if (monstro.isBoss) {
                    msg = `<span class="text-rose-500 font-bold">BATALHA DE CHEFE!</span><br/>` + msg;
                }

                if (game.player.sombraAtiva && game.player.sombraAtiva.statsAtuais) {
                    const s = game.player.sombraAtiva;
                    msg += `<br/><span class="text-purple-300">Sua ${s.nomeSombra} está pronta.</span>`;
                }
                msg += `<br/><br/>Sua vez!`;

                mostrarMensagem(msg);
                limparEscolhas();
                showBattleInterface(true);

                atualizarStatusAtributos();
                updateGoogleSignInUI();
            }

            function gerarLordeDaMorteBaseStats() {
                return {
                    nome: "Lorde da Morte", rank: "S", vidaMax: 4000, vidaAtual: 4000,
                    danoFisico: 200, danoMagico: 150, xpGanho: 0,
                    fugaPct: 0, isBoss: true, isLordeDaMorte: true
                };
            }

            function gerarLordeDaMorteParaDesafio(tipoDesafio) {
                const baseLorde = gerarLordeDaMorteBaseStats();
                let lordeDesafio = { ...baseLorde };

                lordeDesafio.nome = `Lorde da Morte (${tipoDesafio === "lorde_dominio" ? "Desafio de Domínio" : "Desafio de Exército"})`;
                lordeDesafio.isLordeDaMorteDesafio = true;
                lordeDesafio.isLordeDaMorte = false;
                lordeDesafio.xpGanho = 1000 * (tipoDesafio === "lorde_dominio" ? 2 : 4);
                lordeDesafio.manaMax = 500;
                lordeDesafio.manaAtual = 500;


                if (tipoDesafio === "lorde_dominio") {
                    lordeDesafio.vidaMax = Math.floor(baseLorde.vidaMax * 1.5);
                    lordeDesafio.danoFisico = Math.floor(baseLorde.danoFisico * 1.5);
                    lordeDesafio.danoMagico = Math.floor(baseLorde.danoMagico * 1.5);
                    lordeDesafio.vidaAtual = lordeDesafio.vidaMax;
                    lordeDesafio.copiaRecipienteSombras = JSON.parse(JSON.stringify(game.player.recipienteSombras));
                    lordeDesafio.sombraAtivaCopiada = null;
                    lordeDesafio.habilidadesLorde = [
                        { id: "lorde_invocar", nome: "Comando Sombrio", manaBase: 50, efeito: { tipo: "lorde_invoca_sombra_copiada" } }
                    ];

                } else if (tipoDesafio === "lorde_exercito") {
                    lordeDesafio.vidaMax = Math.floor(baseLorde.vidaMax * 2.0);
                    lordeDesafio.danoFisico = Math.floor(baseLorde.danoFisico * 2.0);
                    lordeDesafio.danoMagico = Math.floor(baseLorde.danoMagico * 2.0);
                    lordeDesafio.vidaAtual = lordeDesafio.vidaMax;
                }
                return lordeDesafio;
            }

            function iniciarDesafioLordeDaMorte(tipoDesafio, skillIdAlvo) {
                mostrarMensagem(`Você se prepara para enfrentar o Lorde da Morte em um desafio para <span class="font-bold text-sky-400">${CLASSES_DATA.Necromante.habilidades.find(h => h.id === skillIdAlvo)?.nome || 'uma nova habilidade'}</span>...`);
                limparEscolhas();

                const lordeParaDesafio = gerarLordeDaMorteParaDesafio(tipoDesafio);
                game.monstroAtual = lordeParaDesafio;

                game.batalha.isDesafioClasse = false;
                game.batalha.monstro = lordeParaDesafio;
                game.batalha.skillEmDesafioId = skillIdAlvo;
                game.batalha.tipoDesafioLorde = tipoDesafio;

                if (tipoDesafio === "lorde_exercito") {
                    mostrarMensagem(`Você sente suas energias arcanas e poções seladas! Apenas sua arma responderá neste confronto.`);
                }

                setTimeout(() => {
                    iniciarBatalha(lordeParaDesafio);
                }, 3000);
            }

            function falharDesafioLordeDaMorte() {
                const skillNomeFalha = CLASSES_DATA.Necromante.habilidades.find(h => h.id === game.batalha.skillEmDesafioId)?.nome || "esta poderosa habilidade";
                mostrarMensagem(`O Lorde da Morte o subjugou. Você ainda não está pronto para dominar <span class="font-bold text-sky-400">${skillNomeFalha}</span>.<br/>Treine mais e tente novamente.`);

                game.batalha.skillEmDesafioId = null;
                game.batalha.tipoDesafioLorde = null;
                game.batalha.monstro = null;
                game.batalha.emBatalha = false;

                game.player.vidaAtual = Math.max(1, Math.floor(game.player.vidaMax * 0.25));
                game.player.manaAtual = Math.max(0, Math.floor(game.player.manaMax * 0.25));
                atualizarStatusAtributos();

                limparEscolhas();
                adicionarEscolha("Retornar à tela de Habilidades", abrirSkills);
                adicionarEscolha("Voltar ao Início", abrirInicio);
                toggleHeaderNavButtons(false);
                toggleChatInput(false);
            }
            function iniciarDesafioHabilidade(skillAlvo) {
                if (!game.player.classe) {
                    mostrarMensagem("Você precisa de uma classe para enfrentar desafios de habilidade.");
                    return;
                }
                mostrarMensagem(`Você se prepara para o desafio de dominar <span class="font-bold text-sky-400">${skillAlvo.nome}</span>...<br/>Um eco de suas próprias proezas se materializa!`);
                limparEscolhas();

                const bossClone = gerarBossDesafioClasse(skillAlvo);
                game.batalha.isDesafioClasse = true;
                game.batalha.skillEmDesafioId = skillAlvo.id;
                game.monstroAtual = bossClone;

                setTimeout(() => {
                    iniciarBatalha(bossClone);
                }, 2500);
            }
            function gerarBossDesafioClasse(skillAlvo) {
                const p = game.player;
                const classeAtual = CLASSES_DATA[p.classe];
                let habilidadesBoss = [];

                const primeiraSkillClasse = classeAtual.habilidades.find(h => h.indiceNaClasse === 0);
                if (primeiraSkillClasse) habilidadesBoss.push(primeiraSkillClasse);

                habilidadesBoss.push(skillAlvo);

                if (skillAlvo.indiceNaClasse === 2) {
                    const segundaSkillClasse = classeAtual.habilidades.find(h => h.indiceNaClasse === 1);
                    if (segundaSkillClasse && game.player.magiasAdquiridas.includes(segundaSkillClasse.id)) {
                        habilidadesBoss.push(segundaSkillClasse);
                    }
                }
                habilidadesBoss = [...new Set(habilidadesBoss)];


                const nomeBoss = `Eco Sombrio de ${p.nome}`;
                const rankBoss = p.rank;
                const vidaMaxBoss = Math.floor(p.vidaMax * 0.9);
                const danoFisicoBoss = Math.floor(p.currentDanoFisico * 0.8);
                const danoMagicoBoss = Math.floor(p.currentDanoMagico * 0.8);

                game.batalha.desafioBossOriginalStats = {
                    vidaMax: vidaMaxBoss,
                    danoFisico: danoFisicoBoss,
                    danoMagico: danoMagicoBoss,
                    habilidades: habilidadesBoss.map(h => h.id)
                };

                return {
                    nome: nomeBoss,
                    rank: rankBoss,
                    vidaMax: vidaMaxBoss,
                    vidaAtual: vidaMaxBoss,
                    manaMax: Math.floor(p.manaMax * 0.8),
                    manaAtual: Math.floor(p.manaMax * 0.8),
                    danoFisico: danoFisicoBoss,
                    danoMagico: danoMagicoBoss,
                    xpGanho: 50 * (rankToIndex(rankBoss) + 1),
                    fugaPct: 0,
                    isBoss: true,
                    isDesafioClasseBoss: true,
                    habilidades: habilidadesBoss,
                    usaApenasHabilidades: true
                };
            }

            function desabilitarBotoesAcaoBatalha() {
                const btnUsarArma = document.getElementById("btn-battle-fight");
                const btnSkill = document.getElementById("btn-battle-skill");
                const btnItem = document.getElementById("btn-battle-item");
                const btnEscape = document.getElementById("btn-battle-escape");

                if (btnUsarArma) btnUsarArma.disabled = true;
                if (btnSkill) btnSkill.disabled = true;
                if (btnItem) btnItem.disabled = true;
                if (btnEscape) btnEscape.disabled = true;
            }

            function habilitarBotoesAcaoBatalha() {
                const btnUsarArma = document.getElementById("btn-battle-fight");
                const btnSkill = document.getElementById("btn-battle-skill");
                const btnItem = document.getElementById("btn-battle-item");
                const btnEscape = document.getElementById("btn-battle-escape");
                const monstro = game.batalha.monstro;

                const isArquitetoRefused = monstro?.isArquiteto && game.batalha.arquitetoBattleRefused;

                if (btnUsarArma) btnUsarArma.disabled = false;

                const isDesafioExercito = game.batalha.tipoDesafioLorde === "lorde_exercito";
                const temClasse = !!game.player.classe;
                const temSkillsEquipadas = game.player.magiasEquipadas && game.player.magiasEquipadas.length > 0;
                if (btnSkill) btnSkill.disabled = isArquitetoRefused || isDesafioExercito || !(temClasse && temSkillsEquipadas);

                const temPocoes = game.player.inventario.some(i => i.isPotion && i.quantity > 0);
                if (btnItem) btnItem.disabled = isArquitetoRefused || isDesafioExercito || !temPocoes;

                if (btnEscape) btnEscape.disabled = isArquitetoRefused || (monstro && monstro.isBoss) || (monstro && monstro.isLordeDaMorteDesafio) || (monstro?.isArquiteto && game.batalha.arquitetoBattleRefused);
            }


            function tentarFugir() {
                if (game.batalha.monstro?.isArquiteto && game.batalha.arquitetoBattleRefused) {
                    mostrarMensagem("Contra o Arquiteto, após recusar sua oferta, apenas sua arma básica responde. Poções, habilidades e fuga são inúteis.");
                    // Ensure main battle commands are visible if submenu was open
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    return;
                }
                if (game.batalha.monstro && game.batalha.monstro.isBoss) {
                    mostrarMensagem("Não é possível fugir de uma batalha de chefe!");
                    return;
                }
                game.player.lastDefeatedMonsterInfo = null;
                if (game.player.sombraAtiva) {
                    mostrarMensagem(`Sua ${game.player.sombraAtiva.nomeSombra} recua para as sombras com você.`);
                    game.player.sombraAtiva = null;
                    updateSummonBattleDisplay();
                }

                const chanceFuga = calcularChanceFuga(game.batalha.monstro);
                const sucesso = Math.random() < chanceFuga;
                if (sucesso) {
                    showBattleInterface(false);
                    toggleHeaderNavButtons(false);
                    toggleChatInput(false);
                    mostrarMensagem(`Você tentou fugir e conseguiu escapar do <span class="font-bold text-rose-400">${game.batalha.monstro.nome}</span>!<br/><br/>O que deseja fazer agora?`);
                    game.batalha.emBatalha = false; game.monstroAtual = null;
                    if (game.dungeon.active) {
                        // AQUI ESTÁ O PROBLEMA ORIGINAL: Chama fugirDaMasmorra, que sai completamente.
                        // Precisamos ajustar para que o fluxo da masmorra continue.
                        // Ao invés de fugirDaMasmorra, vamos para a próxima sala ou oferecer opções de dungeon.
                        game.dungeon.currentRoom++; // Avança para a próxima sala (como se tivesse vencido ou um encontro vazio)
                        mostrarMensagem(`Você conseguiu fugir do <span class="font-bold text-rose-400">${game.batalha.monstro.nome}</span> e avança para a próxima sala da masmorra...`);
                        setTimeout(() => {
                            if (game.dungeon.currentRoom >= game.dungeon.totalRooms) { // Se fugiu da última sala (pré-boss), pode sair ou tentar o boss.
                                game.dungeon.isBossRoomConfirmation = true; // Força a confirmação do boss
                                avancarSalaMasmorra(); // Redireciona para a lógica de "última sala"
                            } else {
                                avancarSalaMasmorra(); // Vai para a próxima sala
                            }
                        }, 1000); // Pequeno delay antes de avançar
                        // Não chame abrirInicio() aqui, pois o fluxo da dungeon vai continuar.
                    } else {
                        abrirInicio(); // Se não está em dungeon, volta para o início normal
                    }
                } else {
                    mostrarMensagem(`Você tentou fugir, mas falhou! O <span class="font-bold text-rose-400">${game.batalha.monstro.nome}</span> aproveita para atacar você!`);
                    setTimeout(() => monstroAtaca(), 1000);
                }
                atualizarStatusAtributos();
            }
            function mostrarMenuInvocarSombras() {
                if (!game.batalha.emBatalha || !game.batalha.turnoJogador || game.batalha.jogadorAgiuNoTurno) {
                    mostrarMensagem("Não é o momento de gerenciar suas sombras.");
                    return;
                }

                let msg = "Escolha uma sombra para invocar ou guardar a ativa:";
                const submenu = document.getElementById("battle-submenu-choices");
                submenu.innerHTML = ""; // Clear existing submenu choices
                submenu.classList.remove("hidden");
                document.getElementById("battle-main-commands").classList.add("hidden");

                // Option to dismiss current active shadow
                if (game.player.sombraAtiva) {
                    adicionarEscolha(`Guardar Sombra Ativa (${game.player.sombraAtiva.nomeSombra})`, () => {
                        game.player.recipienteSombras.push(game.player.sombraAtiva);
                        game.player.sombraAtiva = null;
                        game.player.manaAtual = Math.max(0, game.player.manaAtual - 5); // Small mana cost to dismiss in battle
                        mostrarMensagem(`Sua sombra ativa foi guardada. Mana restante: ${game.player.manaAtual}.`);
                        game.batalha.jogadorAgiuNoTurno = true; // Consumes turn
                        updateSummonBattleDisplay();
                        setTimeout(() => monstroAtaca(), 1200);
                    }, false, "Devolve a sombra ativa para o recipiente, custa um pouco de mana e o turno.", "submenu");
                }

                // List available shadows in the recipient
                if (game.player.recipienteSombras.length > 0 && game.player.maxActiveShadows > (game.player.sombraAtiva ? 1 : 0)) {
                    game.player.recipienteSombras.forEach(sombra => {
                        const vidaAtiva = Math.max(1, Math.floor(sombra.statsOriginais.vidaMax * 0.5));
                        const danoBaseAtivo = Math.max(1, Math.floor((sombra.statsOriginais.danoFisico || 0) * 0.5));

                        adicionarEscolha(
                            `Invocar ${sombra.nomeSombra} (Rank ${sombra.rankSombra}) - HP: ${vidaAtiva}, Dano: ${danoBaseAtivo}`,
                            () => {
                                const cost = 10; // Example mana cost to invoke
                                if (game.player.manaAtual < cost) {
                                    mostrarMensagem(`Mana insuficiente para invocar ${sombra.nomeSombra}. Custo: ${cost}.`);
                                    mostrarMenuInvocarSombras(); // Stay in the submenu
                                    return;
                                }
                                game.player.manaAtual -= cost;

                                // If a shadow is already active, put it back in the recipient
                                if (game.player.sombraAtiva) {
                                    game.player.recipienteSombras.push(game.player.sombraAtiva);
                                }

                                // Set the new active shadow
                                game.player.sombraAtiva = {
                                    ...sombra,
                                    statsAtuais: { vidaMax: vidaAtiva, vidaAtual: vidaAtiva, danoBase: danoBaseAtivo }
                                };
                                // Remove from recipient
                                game.player.recipienteSombras = game.player.recipienteSombras.filter(s => s.id !== sombra.id);

                                mostrarMensagem(`${sombra.nomeSombra} foi invocada! Mana restante: ${game.player.manaAtual}.`);
                                game.batalha.jogadorAgiuNoTurno = true; // Consumes turn
                                updateSummonBattleDisplay();
                                updatePlayerBattleDisplay();
                                atualizarRecipienteSombrasTela(); // Update inventory view if open
                                setTimeout(() => monstroAtaca(), 1200); // Enemy turn
                            },
                            false,
                            `Invoca esta sombra para lutar. Custo: 10 mana.`,
                            "submenu"
                        );
                    });
                } else if (!game.player.sombraAtiva) {
                    adicionarEscolha("Recipiente de Sombras Vazio ou Limite Atingido", null, true, "Você não tem sombras para invocar ou já atingiu o limite de sombras ativas.", "submenu");
                }

                adicionarEscolha("<i class='fas fa-arrow-left mr-2'></i>Voltar", () => {
                    submenu.innerHTML = "";
                    submenu.classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    mostrarMensagem(`Turno do jogador. O que deseja fazer?`);
                }, false, "Voltar para as ações principais", "submenu");
            }


            function atacarMonstro(tipo, skill = null) {
                if (!game.batalha.emBatalha || !game.batalha.monstro) return;
                const monstro = game.batalha.monstro;
                let dano = 0;
                let msgPart = "";
                let selfDamageMsg = "";
                let playerDefeatedBySkill = false;
                let mainMsg = "";
                let shadowAttackMsg = "";

                if (tipo === "fisico") {
                    dano = calcularDanoFisico();
                    msgPart = "um ataque físico";
                } else if (tipo === "magico" && skill) {
                    // --- IMPORTANT: Handle "Invocar Sombra" as a menu trigger, not a direct attack ---
                    if (skill.efeito?.tipo === "invocar_sombra") {
                        mostrarMensagem("Escolha uma sombra para invocar ou guardar a ativa:");
                        mostrarMenuInvocarSombras();
                        return;
                    }

                    const gastoMana = calcularGastoMana(skill);
                    if (game.player.manaAtual < gastoMana) {
                        mostrarMensagem(`Você não tem mana suficiente para usar <span class="font-bold text-sky-400">${skill.nome}</span>. Mana necessária: ${gastoMana}`);
                        return;
                    }
                    game.player.manaAtual -= gastoMana;
                    msgPart = `a habilidade <span class="font-bold text-sky-400">${skill.nome}</span>`;
                    game.batalha.jogadorAgiuNoTurno = true; // Consumes turn for non-invocation skills
                    desabilitarBotoesAcaoBatalha();

                    // --- Lógica de Efeitos da Habilidade ---
                    if (skill.efeito) {
                        switch (skill.efeito.tipo) {
                            // Inside atacarMonstro, within the 'else if (tipo === "magico" && skill)' block,
                            // inside the 'switch (skill.efeito.tipo)'
                            // ... existing cases ...
                            case "escape_battle_dungeon": // Monarca: Troca de Sombras
                                if (game.player.classe === "Necromante" && game.player.isMarcado) {
                                    mostrarMensagem("Com um piscar de sombras, você troca de lugar com um servo distante e escapa ileso!");
                                    game.batalha.emBatalha = false;
                                    game.batalha.monstro = null;
                                    if (game.dungeon.active) {
                                        game.dungeon.active = false;
                                        // Optionally, add a penalty or specific message for leaving dungeon this way
                                    }
                                    game.player.activeBuffs = []; // Clear buffs on escape
                                    showBattleInterface(false);
                                    game.batalha.jogadorAgiuNoTurno = true; // Consumes turn, but battle ends
                                    desabilitarBotoesAcaoBatalha(); // Disable further actions
                                    setTimeout(() => {
                                        abrirInicio(); // Go to main screen
                                        toggleHeaderNavButtons(false);
                                        toggleChatInput(false);
                                    }, 1500);
                                    dano = 0;
                                } else {
                                    msgPart += ", mas o poder da troca falha."; dano = 0;
                                }
                                break;

                            case "critical_strike_conditional": // Monarca: Acerto Crítico
                                if (game.player.classe === "Necromante" && game.player.isMarcado) {
                                    if (rankToIndex(game.player.rank) > rankToIndex(monstro.rank)) {
                                        dano = Math.floor((game.player.currentDanoFisico + game.player.currentDanoMagico) * 2);
                                        msgPart += ` com um <span class="font-bold text-red-400">Golpe Devastador do Monarca</span>`;
                                    } else {
                                        dano = calcularDanoFisico();
                                        msgPart += `, mas a aura do inimigo era muito forte para um golpe crítico total. O ataque causa dano físico normal`;
                                    }
                                } else {
                                    dano = calcularDanoFisico(); msgPart += ", mas o poder do monarca não fluiu. O ataque causa dano físico normal";
                                }
                                break;

                            case "full_restore": // Monarca: Recuperação Total
                                if (game.player.classe === "Necromante" && game.player.isMarcado) {
                                    game.player.vidaAtual = game.player.vidaMax;
                                    game.player.manaAtual = game.player.manaMax;
                                    msgPart += ` e <span class="text-emerald-300">restaurou completamente sua Vida e Mana</span> com poder sombrio!`;
                                    dano = 0;
                                } else {
                                    msgPart += ", mas a energia da recuperação não se manifestou."; dano = 0;
                                }
                                break;

                            case "extracao_sombra":
                                if (game.player.lastDefeatedMonsterInfo) {
                                    if (game.player.recipienteSombras.length >= game.player.recipienteCapacity) {
                                        msgPart += `, mas seu Recipiente de Sombras está cheio! Não foi possível extrair a sombra.`;
                                        game.player.manaAtual += gastoMana; // Refund mana if extraction fails due to full capacity
                                    } else {
                                        const lastMonster = game.player.lastDefeatedMonsterInfo;
                                        const newRankIndex = Math.max(0, rankToIndex(lastMonster.rank) - 1);
                                        const shadowRank = indexToRank(newRankIndex);
                                        const shadowId = crypto.randomUUID();
                                        const newShadow = {
                                            id: shadowId, nomeOriginal: lastMonster.nome, nomeSombra: `Sombra de ${lastMonster.nome}`,
                                            rankOriginal: lastMonster.rank, rankSombra: shadowRank,
                                            statsOriginais: { vidaMax: lastMonster.vidaMax, danoFisico: lastMonster.danoFisico, danoMagico: lastMonster.danoMagico }
                                        };
                                        game.player.recipienteSombras.push(newShadow);
                                        msgPart += ` em um ritual profano. Você extraiu a <span class="text-purple-300">${newShadow.nomeSombra} (Rank ${newShadow.rankSombra})</span> e a guardou no Recipiente!`;
                                        game.player.lastDefeatedMonsterInfo = null;
                                        atualizarRecipienteSombrasTela();
                                    }
                                } else {
                                    msgPart += `, mas não havia uma essência de monstro recém-derrotado para extrair.`;
                                }
                                dano = 0; // Extraction doesn't deal damage
                                break;

                            case "ataque_exercito_sombras_completo":
                                if (game.player.recipienteSombras.length === 0 && !game.player.sombraAtiva) {
                                    msgPart += `, mas seu recipiente de sombras está vazio e nenhuma sombra ativa! O ritual falha.`;
                                    game.player.manaAtual += gastoMana; // Refund mana if no shadows to attack with
                                    dano = 0;
                                } else {
                                    msgPart += `! <span class="text-red-500 font-bold">Um portal sombrio se abre!</span>`;
                                    let danoTotalExercito = 0;
                                    let sombrasAtacantesDesc = [];

                                    if (game.player.sombraAtiva && game.player.sombraAtiva.statsAtuais) {
                                        const sa = game.player.sombraAtiva;
                                        let danoSombraIndividual = Math.max(1, sa.statsAtuais.danoBase + rankToIndex(sa.rankSombra));
                                        const dominioBuff = game.player.activeBuffs.find(b => b.id === 'n_dominio_sombras');
                                        if (dominioBuff) {
                                            danoSombraIndividual = Math.floor(danoSombraIndividual * (1 + dominioBuff.valor));
                                        }
                                        danoTotalExercito += danoSombraIndividual;
                                        sombrasAtacantesDesc.push(`${sa.nomeSombra} (Rank ${sa.rankSombra}) causando ${danoSombraIndividual}`);
                                    }

                                    game.player.recipienteSombras.forEach(sombraRecipiente => {
                                        const danoBaseSombraRecipiente = Math.max(1, Math.floor((sombraRecipiente.statsOriginais.danoFisico || 0) * 0.5));
                                        let danoSombraIndividual = Math.max(1, danoBaseSombraRecipiente + rankToIndex(sombraRecipiente.rankSombra));
                                        danoTotalExercito += danoSombraIndividual;
                                        sombrasAtacantesDesc.push(`${sombraRecipiente.nomeSombra} (Rank ${sombraRecipiente.rankSombra}) causando ${danoSombraIndividual}`);
                                    });

                                    dano = danoTotalExercito;
                                    msgPart += `<br/>Seu exército de ${game.player.recipienteSombras.length + (game.player.sombraAtiva ? 1 : 0)} sombras ataca em uníssono!`;
                                }
                                break;

                            case "dano_caotico": // Melodia do Caos do Bardo
                                const playerRankIndex = rankToIndex(game.player.rank);
                                const monsterRankIndex = rankToIndex(monstro.rank);
                                const rankDiff = playerRankIndex - monsterRankIndex;
                                if (rankDiff > 0) {
                                    dano = Math.floor((skill.danoBase || 30) * (1 + 0.10 * rankDiff));
                                    msgPart += `. A melodia enfraquece o inimigo!`;
                                } else if (rankDiff === 0) {
                                    dano = Math.floor(monstro.vidaMax * 0.50);
                                    const selfDmg = Math.floor(game.player.vidaMax * 0.30);
                                    game.player.vidaAtual -= selfDmg;
                                    selfDamageMsg = ` A canção ressoa perigosamente, causando <span class="font-bold text-orange-400">${selfDmg}</span> de dano a você!`;
                                    msgPart += `. A canção atinge um equilíbrio caótico!`;
                                } else {
                                    dano = 0;
                                    const selfDmgPercentage = 0.35 + (0.05 * Math.abs(rankDiff));
                                    const selfDmg = Math.floor(game.player.vidaMax * selfDmgPercentage);
                                    game.player.vidaAtual -= selfDmg;
                                    selfDamageMsg = ` A melodia se volta contra você, causando <span class="font-bold text-orange-400">${selfDmg}</span> de dano! O monstro parece ileso.`;
                                    msgPart += `. A canção é suprimida pela força do inimigo!`;
                                }
                                if (game.player.vidaAtual <= 0) {
                                    game.player.vidaAtual = 0;
                                    playerDefeatedBySkill = true;
                                }
                                break;

                            case "cura": // Cura do Paladino
                                const cura = Math.floor(skill.efeito.valor_base + (game.player.atributos.inteligencia * (skill.efeito.escala_inteligencia || 0)));
                                game.player.vidaAtual = Math.min(game.player.vidaAtual + cura, game.player.vidaMax);
                                msgPart += ` e curou <span class="font-bold text-emerald-400">${cura}</span> de vida!`;
                                dano = 0; // Habilidades de cura não causam dano
                                break;

                            case "cura_percentual_vida_max": // Milagre de Música do Bardo
                                const curaPct = Math.floor(game.player.vidaMax * skill.efeito.valor);
                                game.player.vidaAtual = Math.min(game.player.vidaAtual + curaPct, game.player.vidaMax);
                                msgPart += ` e curou <span class="font-bold text-emerald-400">${curaPct}</span> de vida!`;
                                dano = 0; // Habilidades de cura não causam dano
                                break;

                            case "buff_dano_fisico":
                            case "buff_resistencia":
                            case "buff_dano_sombra_ativa":
                                // Remove buff existente do mesmo tipo antes de adicionar um novo
                                game.player.activeBuffs = game.player.activeBuffs.filter(b => b.id !== skill.id);
                                game.player.activeBuffs.push({
                                    id: skill.id,
                                    nomeSkill: skill.nome,
                                    tipo: skill.efeito.tipo,
                                    valor: skill.efeito.valor,
                                    duracao: skill.efeito.duracao // Duração já inclui o turno atual
                                });
                                msgPart += ` e ativou ${skill.nome}!`;
                                // Reaplicar atributos derivados para que os buffs sejam considerados
                                atualizarAtributosDerivados();
                                dano = 0; // Buffs não causam dano direto
                                break;

                            case "debuff_precisao_inimigo":
                            case "debuff_agilidade_inimigo":
                            case "debuff_defesa_inimigo":
                                // Adicionar debuff ao monstro. Vamos precisar de um array de buffs/debuffs para o monstro.
                                if (!monstro.activeDebuffs) monstro.activeDebuffs = [];
                                // Remover debuff existente do mesmo tipo antes de adicionar um novo
                                monstro.activeDebuffs = monstro.activeDebuffs.filter(d => d.id !== skill.id);
                                monstro.activeDebuffs.push({
                                    id: skill.id,
                                    nomeSkill: skill.nome,
                                    tipo: skill.efeito.tipo,
                                    valor: skill.efeito.valor,
                                    duracao: skill.efeito.duracao // Duração já inclui o turno atual
                                });
                                msgPart += ` e aplicou um efeito em ${monstro.nome}!`;
                                dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * 0.5);
                                break;

                            case "chance_atordoar":
                                // Atordoar o inimigo. Precisa de uma flag de "atordoado" no monstro.
                                dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * 0.5);
                                if (Math.random() < skill.efeito.chance) {
                                    monstro.isStunned = true;
                                    monstro.stunDuration = 1; // Atordoado por 1 turno do monstro
                                    msgPart += ` e atordoou ${monstro.nome}!`;
                                } else {
                                    msgPart += `, mas não atordoou ${monstro.nome}.`;
                                }
                                break;

                            case "dot": // Damage over Time (Sangramento, Veneno)
                                // Adicionar DoT ao monstro. Precisa de um array de DoTs no monstro.
                                if (!monstro.activeDots) monstro.activeDots = [];
                                // Remover DoT existente do mesmo tipo (para não acumular o mesmo sangramento/veneno)
                                monstro.activeDots = monstro.activeDots.filter(d => d.id !== skill.id);
                                monstro.activeDots.push({
                                    id: skill.id,
                                    nomeSkill: skill.nome,
                                    danoPorTurno: skill.efeito.dano_por_turno,
                                    duracao: skill.efeito.duracao,
                                    tipoDanoDot: skill.efeito.tipoDanoDot || "fisico" // default para fisico se não especificado
                                });
                                msgPart += ` e causou ${skill.nome} em ${monstro.nome}!`;
                                dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * 0.5);
                                break;

                            case "multi_hit": // Chuva de Flechas
                                const numeroDeHits = skill.efeito.hits || 1;
                                let danoTotalMultiHit = 0;
                                for (let i = 0; i < numeroDeHits; i++) {
                                    let danoBaseSkill = (skill.danoBase || 0) + (skill.tipoDano === "magico" ? game.player.currentDanoMagico : game.player.currentDanoFisico * 0.5);
                                    danoTotalMultiHit += Math.floor(danoBaseSkill * (skill.danoMultiplicador || 1.0));
                                }
                                dano = danoTotalMultiHit;
                                msgPart += ` e disparou ${numeroDeHits} flechas!`;
                                break;

                            case "dano_bonus_vida_baixa": // Execução do Assassino
                                dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * 0.5);
                                if (monstro.vidaAtual / monstro.vidaMax <= skill.efeito.limiar_vida) {
                                    dano = Math.floor(dano * skill.efeito.multiplicador);
                                    msgPart += ` com dano bônus de execução!`;
                                }
                                break;

                            case "ignora_defesa_parcial": // Virote Pesado da Besta
                                dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * (skill.danoMultiplicador || 1.0));
                                // Para simplificar, vou aplicar como dano adicional direto, mas idealmente seria ignorar a resistência.
                                // Para uma implementação mais precisa, você precisaria aplicar a redução de defesa ao monstro.
                                // Por enquanto, vamos fazer um dano extra.
                                dano += Math.floor(dano * (skill.efeito.valor || 0.1));
                                msgPart += ` ignorando parte da armadura!`;
                                break;

                            default:
                                // Habilidades que causam dano padrão sem efeito específico aqui
                                dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * 0.5);
                                break;
                        }
                    } else {
                        // Se não tem efeito, é uma skill de dano base
                        dano = (skill.tipoDano === "magico") ? calcularDanoMagico(skill) : skill.danoBase + Math.floor(game.player.currentDanoFisico * 0.5);
                    }
                }

                if (dano > 0) monstro.vidaAtual -= dano;
                if (monstro.vidaAtual < 0) monstro.vidaAtual = 0;

                mainMsg = `Você usou ${msgPart} no <span class="font-bold text-rose-400">${monstro.nome}</span>`;
                if (dano > 0) {
                    mainMsg += ` e causou <span class="font-bold text-amber-400">${dano}</span> de dano.`;
                } else if (!(skill && (skill.efeito?.tipo === "extracao_sombra" || skill.efeito?.tipo.startsWith("cura") || skill.id === 'b_melodia_caos' || skill.efeito?.tipo.startsWith("buff") || skill.efeito?.tipo.startsWith("debuff") || skill.efeito?.tipo === "ataque_exercito_sombras_completo"))) {
                    // Only append "não causou dano direto" if it was truly a non-damaging action.
                    mainMsg += `, mas não causou dano direto.`;
                }
                mainMsg += `<br/>Vida do monstro: ${monstro.vidaAtual} / ${monstro.vidaMax}.`;
                if (selfDamageMsg) mainMsg += selfDamageMsg;
                if (tipo === "magico") mainMsg += `<br/>Mana restante: ${game.player.manaAtual} / ${game.player.manaMax}.`;


                // Shadow's attack logic after player's action
                if (game.player.sombraAtiva && monstro.vidaAtual > 0 && !playerDefeatedBySkill && game.player.sombraAtiva.statsAtuais) {
                    const sombra = game.player.sombraAtiva;
                    const danoSombra = Math.max(1, sombra.statsAtuais.danoBase + rankToIndex(sombra.rankSombra));
                    monstro.vidaAtual -= danoSombra;
                    if (monstro.vidaAtual < 0) monstro.vidaAtual = 0;
                    shadowAttackMsg = `<br/>Sua <span class="text-purple-300">${sombra.nomeSombra}</span> ataca, causando <span class="font-bold text-violet-400">${danoSombra}</span> de dano! Vida do monstro: ${monstro.vidaAtual} / ${monstro.vidaMax}.`;
                }
                mainMsg += shadowAttackMsg;

                if (playerDefeatedBySkill) mainMsg += `<br/><br/><span class="font-bold text-rose-500">Sua própria magia o derrotou!</span>`;

                mostrarMensagem(mainMsg);
                atualizarStatusAtributos();
                updatePlayerBattleDisplay();
                updateEnemyBattleDisplay(monstro);
                updateSummonBattleDisplay();

                // Check for battle end or proceed to monster's turn
                if (playerDefeatedBySkill) {
                    setTimeout(() => { showBattleInterface(false); gameOver(); }, 1500);
                } else if (monstro.vidaAtual <= 0) {
                    setTimeout(() => { showBattleInterface(false); derrotarMonstro(monstro); }, 1200);
                } else {
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    setTimeout(() => monstroAtaca(), 1200);
                }
            }
            function mostrarHabilidadesArma() {
                if (!game.batalha.emBatalha || !game.batalha.turnoJogador || game.batalha.jogadorAgiuNoTurno) {
                    if (game.batalha.jogadorAgiuNoTurno) mostrarMensagem("Você já agiu neste turno.");
                    return;
                }

                const armaEquipada = game.player.equipamento.arma;
                const tipoArmaKey = armaEquipada ? armaEquipada.subTipoArma : "Nenhuma";
                const dadosArma = TIPOS_DE_ARMAS[tipoArmaKey] || TIPOS_DE_ARMAS["Nenhuma"];

                if (!dadosArma || !dadosArma.habilidades || dadosArma.habilidades.length === 0) {
                    mostrarMensagem("Nenhuma habilidade de arma disponível. Algo deu errado.");
                    return;
                }

                mostrarMensagem(`Escolha uma habilidade para ${dadosArma.nomeDisplay}:`);
                const submenu = document.getElementById("battle-submenu-choices");
                submenu.innerHTML = "";

                dadosArma.habilidades.forEach(habilidade => {
                    let infoHabilidade = `${habilidade.nome} (Mana: ${habilidade.custoMana || 0})`;
                    let tituloDesc = `${habilidade.descricao} Dano: ${Math.floor((habilidade.danoMultiplicador || 1) * 100)}%`;
                    if (habilidade.hits > 1) tituloDesc += ` (${habilidade.hits}x)`;

                    const manaInsuficiente = (habilidade.custoMana || 0) > game.player.manaAtual;
                    let btnTexto = infoHabilidade;
                    if (manaInsuficiente) btnTexto += " (Mana Insuficiente)";

                    adicionarEscolha(
                        btnTexto,
                        () => {
                            executarHabilidadeArma(habilidade, dadosArma.nomeDisplay);
                        },
                        manaInsuficiente,
                        tituloDesc,
                        "submenu"
                    );
                });

                adicionarEscolha("<i class='fas fa-arrow-left mr-2'></i>Voltar", () => {
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    if (game.batalha.emBatalha) mostrarMensagem(`Turno do jogador. O que deseja fazer?`);
                }, false, "Voltar para as ações principais", "submenu");
            }

            function executarHabilidadeArma(habilidade, nomeArmaUsada) {
                if (!game.batalha.emBatalha || !game.batalha.monstro || game.batalha.jogadorAgiuNoTurno) {
                    if (game.batalha.jogadorAgiuNoTurno) mostrarMensagem("Você já agiu neste turno.");
                    return;
                }

                const monstro = game.batalha.monstro;
                // MODIFICADO: Calcular custo de mana (incluindo percentual)
                let custoMana;
                if (habilidade.custoManaPercent !== undefined) {
                    custoMana = Math.floor(game.player.manaMax * habilidade.custoManaPercent);
                } else {
                    custoMana = habilidade.custoMana || 0;
                }

                if (game.player.manaAtual < custoMana) {
                    mostrarMensagem(`Você não tem mana suficiente para usar ${habilidade.nome}. Mana necessária: ${custoMana}.`);
                    const submenu = document.getElementById("battle-submenu-choices");
                    submenu.innerHTML = "";
                    submenu.classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    habilitarBotoesAcaoBatalha();
                    mostrarHabilidadesArma(); // Re-show skill list so player can choose another or cancel
                    return;
                }
                game.player.manaAtual -= custoMana;

                let danoTotalCausado = 0;
                let logHits = [];
                const numeroDeHits = habilidade.hits || 1;
                let msg = `Você usou <span class="font-bold text-cyan-400">${habilidade.nome}</span> com sua ${nomeArmaUsada}.`; // Mensagem inicial
                let danoAplicadoAoMonstro = true; // Flag para saber se o dano é no monstro ou outro efeito

                // NOVO: Lógica para "I'm Atomic" (damage_percentage_current_hp)
                if (habilidade.efeito?.tipo === "damage_percentage_current_hp") {
                    const danoPercentual = Math.floor(monstro.vidaAtual * habilidade.efeito.valor);
                    danoTotalCausado = danoPercentual;
                    logHits.push(danoTotalCausado); // Registra como um único hit para consistência de log
                    msg += ` Uma onda de energia pura engole o inimigo!`;
                }
                // NOVO: Lógica para "Time Stop" (enemy_stun_turns) - não causa dano direto
                else if (habilidade.efeito?.tipo === "enemy_stun_turns") {
                    monstro.isStunned = true;
                    monstro.stunDuration = (monstro.stunDuration || 0) + habilidade.efeito.duracao;
                    msg += ` O tempo para ao redor do ${monstro.nome} por ${habilidade.efeito.duracao} turno(s)!`;
                    danoAplicadoAoMonstro = false; // Time Stop não causa dano
                    danoTotalCausado = 0; // Garante que nenhum dano seja aplicado
                } else { // Lógica existente para outros tipos de dano e habilidades com hits
                    for (let i = 0; i < numeroDeHits; i++) {
                        let danoDoHit;
                        // NOVO: Checar por danoBase fixo na habilidade (ex: Speed Slash, Devastation)
                        if (habilidade.danoBase !== undefined) {
                            danoDoHit = habilidade.danoBase; // Dano fixo por hit
                        } else { // Dano baseado nos stats do jogador e multiplicador da skill
                            let danoBaseJogador = calcularDanoFisico(); // Ou outra lógica se a skill for mágica
                            danoDoHit = Math.floor(danoBaseJogador * (habilidade.danoMultiplicador || 1.0));
                        }

                        if (habilidade.efeito?.tipo === "ignora_defesa_parcial" && monstro.rank !== "S") {
                            // Este efeito pode precisar de ajuste se danoBase for usado, pois ignora_defesa_parcial
                            // geralmente é um bônus sobre o dano calculado.
                            // Se danoBase é absoluto, este bônus pode ser aplicado a ele ou ser um efeito separado.
                            // Por ora, aplicaremos ao danoDoHit calculado.
                            danoDoHit = Math.floor(danoDoHit * (1 + (habilidade.efeito.valor || 0.1)));
                        }
                        danoTotalCausado += danoDoHit;
                        logHits.push(danoDoHit);
                    }
                }

                if (danoAplicadoAoMonstro && danoTotalCausado > 0) {
                    monstro.vidaAtual -= danoTotalCausado;
                    if (monstro.vidaAtual < 0) monstro.vidaAtual = 0;
                }


                game.batalha.jogadorAgiuNoTurno = true;
                desabilitarBotoesAcaoBatalha();

                // Mensagem de dano (ajustada)
                if (habilidade.efeito?.tipo === "damage_percentage_current_hp") {
                    msg += ` Causou <span class="font-bold text-amber-400">${danoTotalCausado}</span> de dano (${(habilidade.efeito.valor * 100).toFixed(0)}% da vida atual).`;
                } else if (habilidade.efeito?.tipo === "enemy_stun_turns") {
                    // A mensagem de stun já foi adicionada. Não precisa de mensagem de dano.
                } else if (numeroDeHits > 1) { // Para multi-hit skills como Devastation
                    msg += ` Atingiu ${numeroDeHits} vezes, causando ${logHits.join(' + ')} = <span class="font-bold text-amber-400">${danoTotalCausado}</span> de dano.`;
                } else if (danoTotalCausado > 0) { // Para Speed Slash e outros single hits com dano
                    msg += ` Causou <span class="font-bold text-amber-400">${danoTotalCausado}</span> de dano.`;
                } else if (!danoAplicadoAoMonstro) {
                    // Mensagem já tratada (ex: Time Stop)
                } else {
                    msg += ` Mas não causou dano direto.`; // Se uma habilidade ofensiva por algum motivo não causou dano
                }


                if (habilidade.efeito && habilidade.efeito.tipo !== "damage_percentage_current_hp" && habilidade.efeito.tipo !== "enemy_stun_turns") {
                    switch (habilidade.efeito.tipo) {
                        case "debuff_precisao_inimigo":
                            msg += ` O inimigo parece desorientado!`;
                            // Implementar lógica de debuff no monstro se necessário
                            if (!monstro.activeDebuffs) monstro.activeDebuffs = [];
                            monstro.activeDebuffs = monstro.activeDebuffs.filter(d => d.id !== habilidade.id); // Evitar duplicatas
                            monstro.activeDebuffs.push({ id: habilidade.id, tipo: "debuff_precisao_inimigo", valor: habilidade.efeito.valor, duracao: habilidade.efeito.duracao, nomeSkill: habilidade.nome });
                            break;
                        case "chance_atordoar":
                            if (Math.random() < habilidade.efeito.chance) {
                                msg += ` O inimigo está atordoado!`;
                                monstro.isStunned = true;
                                monstro.stunDuration = (monstro.stunDuration || 0) + 1; // Adiciona 1 turno ao stun existente ou inicia
                            }
                            break;
                        case "debuff_defesa_inimigo":
                            msg += ` A defesa do inimigo foi reduzida!`;
                            if (!monstro.activeDebuffs) monstro.activeDebuffs = [];
                            monstro.activeDebuffs = monstro.activeDebuffs.filter(d => d.id !== habilidade.id);
                            monstro.activeDebuffs.push({ id: habilidade.id, tipo: "debuff_defesa_inimigo", valor: habilidade.efeito.valor, duracao: habilidade.efeito.duracao, nomeSkill: habilidade.nome });
                            break;
                        case "dot":
                            msg += ` O inimigo começa a sangrar!`;
                            if (!monstro.activeDots) monstro.activeDots = [];
                            monstro.activeDots = monstro.activeDots.filter(d => d.id !== habilidade.id);
                            monstro.activeDots.push({ id: habilidade.id, danoPorTurno: habilidade.efeito.dano_por_turno, duracao: habilidade.efeito.duracao, tipoDanoDot: habilidade.efeito.tipoDanoDot || "fisico", nomeSkill: habilidade.nome });
                            break;
                        case "debuff_agilidade_inimigo":
                            msg += ` Os movimentos do inimigo foram dificultados!`;
                            if (!monstro.activeDebuffs) monstro.activeDebuffs = [];
                            monstro.activeDebuffs = monstro.activeDebuffs.filter(d => d.id !== habilidade.id);
                            monstro.activeDebuffs.push({ id: habilidade.id, tipo: "debuff_agilidade_inimigo", valor: habilidade.efeito.valor, duracao: habilidade.efeito.duracao, nomeSkill: habilidade.nome });
                            break;
                    }
                }

                msg += `<br/>Vida do <span class="font-bold text-rose-400">${monstro.nome}</span>: ${monstro.vidaAtual} / ${monstro.vidaMax}.`;
                if (custoMana > 0) msg += `<br/>Mana restante: ${game.player.manaAtual} / ${game.player.manaMax}.`;

                let shadowAttackMsg = "";
                if (game.player.sombraAtiva && monstro.vidaAtual > 0 && game.player.sombraAtiva.statsAtuais) {
                    const sombra = game.player.sombraAtiva;
                    const danoSombra = Math.max(1, sombra.statsAtuais.danoBase + rankToIndex(sombra.rankSombra));
                    monstro.vidaAtual -= danoSombra;
                    if (monstro.vidaAtual < 0) monstro.vidaAtual = 0;
                    shadowAttackMsg = `<br/>Sua <span class="text-purple-300">${sombra.nomeSombra}</span> ataca, causando <span class="font-bold text-violet-400">${danoSombra}</span> de dano! Vida do monstro: ${monstro.vidaAtual} / ${monstro.vidaMax}.`;
                }
                msg += shadowAttackMsg;


                mostrarMensagem(msg);
                atualizarStatusAtributos(); // Atualiza status gerais
                updatePlayerBattleDisplay(); // Atualiza display de batalha do jogador
                updateEnemyBattleDisplay(monstro); // Atualiza display de batalha do inimigo
                updateSummonBattleDisplay(); // Atualiza display da sombra

                document.getElementById("battle-submenu-choices").innerHTML = "";
                document.getElementById("battle-submenu-choices").classList.add("hidden");
                document.getElementById("battle-main-commands").classList.remove("hidden");

                if (monstro.vidaAtual <= 0) {
                    setTimeout(() => { showBattleInterface(false); derrotarMonstro(monstro); }, 1500);
                } else {
                    setTimeout(() => monstroAtaca(), 1500);
                }
            }

            function usarMagiaMenu() {
                if (game.batalha.monstro?.isArquiteto && game.batalha.arquitetoBattleRefused) {
                    mostrarMensagem("Contra o Arquiteto, após recusar sua oferta, apenas sua arma básica responde. Poções, habilidades e fuga são inúteis.");
                    // Ensure main battle commands are visible if submenu was open
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    return;
                }
                if (game.batalha.tipoDesafioLorde === "lorde_exercito") {
                    mostrarMensagem("Suas habilidades de classe estão seladas neste desafio! Use sua arma.");
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    habilitarBotoesAcaoBatalha();
                    return;
                }
                if (!game.player.classe) {
                    mostrarMensagem("Você precisa de uma classe para usar habilidades!");
                    return;
                }
                const classeAtualData = CLASSES_DATA[game.player.classe];
                if (!classeAtualData) { mostrarMensagem("Erro: Dados da classe não encontrados."); return; }

                const magiasEquipadasDetalhes = game.player.magiasEquipadas
                    .map(id => classeAtualData.habilidades.find(h => h.id === id))
                    .filter(Boolean);

                if (magiasEquipadasDetalhes.length === 0) {
                    mostrarMensagem("Você não tem habilidades de classe equipadas.");
                    return;
                }

                mostrarMensagem("Escolha a habilidade para usar:");
                const submenu = document.getElementById("battle-submenu-choices");
                submenu.innerHTML = "";

                magiasEquipadasDetalhes.forEach(skill => {
                    let skillInfo = `${skill.nome} (Rank ${skill.rank})`;
                    let effectDetails = [];
                    if (skill.danoBase) effectDetails.push(`Dano Base: ${skill.danoBase}`);
                    if (skill.efeito?.tipo === "cura_percentual_vida_max") effectDetails.push(`Cura: ${skill.efeito.valor * 100}% Max Vida`);
                    if (skill.efeito?.tipo === "extracao_sombra") {
                        effectDetails.push(game.player.lastDefeatedMonsterInfo ? `Alvo: ${game.player.lastDefeatedMonsterInfo.nome}` : `Nenhum alvo`);
                    }
                    if (skill.efeito?.tipo === "ataque_exercito_sombras_completo") effectDetails.push(`Ataque de Exército`);

                    const custoMana = calcularGastoMana(skill);
                    skillInfo += ` - Mana: ${custoMana}`;
                    let titleText = skill.descricao;
                    if (effectDetails.length > 0) titleText += " | " + effectDetails.join("; ");

                    let isDisabled = game.player.manaAtual < custoMana;

                    if (skill.efeito?.tipo === "extracao_sombra" && !game.player.lastDefeatedMonsterInfo) {
                        isDisabled = true;
                        skillInfo += " (Sem Alvo)";
                    }
                    if (skill.efeito?.tipo === "ataque_exercito_sombras_completo" && (game.player.recipienteSombras.length === 0 && !game.player.sombraAtiva)) {
                        isDisabled = true;
                        skillInfo += " (Sem Sombras)";
                    }

                    // --- NEW LOGIC FOR INVOKING SHADOWS ---
                    if (skill.efeito?.tipo === "invocar_sombra") {
                        // "Invocar Sombra" should *always* be available to open the menu,
                        // but individual actions within that menu might be disabled.
                        // Mana cost will be applied when a choice is made in the shadow menu.

                        // Check if there are any shadows to interact with (either active or in recipient)
                        const hasAnyShadowsToManage = game.player.sombraAtiva || game.player.recipienteSombras.length > 0;

                        // If the player doesn't have any shadows acquired yet, disable the skill to open the menu.
                        // Also, consider the Necromancer's specific unlock condition for these skills.
                        if (!game.player.metLordeDaMorte && (skill.id === "n_extracao_sombras" || skill.id === "n_invocar_sombra")) {
                            isDisabled = true;
                            skillInfo += " (Requer Lorde da Morte)";
                        } else if (!hasAnyShadowsToManage) {
                            // If the skill is "Invocar Sombra" and there are no shadows in recipient AND no active shadow,
                            // then the skill is effectively unusable.
                            isDisabled = true;
                            skillInfo += " (Recipiente Vazio)";
                        }

                        // The 'mana cost' shown for the button to open the menu can be a base cost
                        // or 0, as the real cost is on the action inside the menu.
                        const displayCost = 10; // A nominal cost to open the shadow menu, or the actual cost if you want to apply it here.
                        skillInfo = `${skill.nome} (Rank ${skill.rank}) - Mana: ${displayCost}`;
                        if (isDisabled) {
                            skillInfo += " (Não Disponível)";
                        }

                        adicionarEscolha(skillInfo, () => {
                            // Before opening the menu, if a cost is applied to opening the menu:
                            // if (game.player.manaAtual < displayCost) {
                            //     mostrarMensagem(`Mana insuficiente para abrir o menu de sombras. Mana necessária: ${displayCost}`);
                            //     return;
                            // }
                            // game.player.manaAtual -= displayCost; // Consume mana to open menu
                            // updatePlayerBattleDisplay(); // Update display for mana cost
                            mostrarMenuInvocarSombras(); // Open the dedicated shadow menu
                            // Don't desabilitarBotoesAcaoBatalha here, as the shadow menu will handle turn.
                        }, isDisabled, titleText, "submenu");

                    } else {
                        // Original logic for other skills that deal damage or apply effects directly
                        adicionarEscolha(skillInfo, () => {
                            atacarMonstro("magico", skill);
                            document.getElementById("battle-submenu-choices").innerHTML = "";
                            document.getElementById("battle-submenu-choices").classList.add("hidden");
                            document.getElementById("battle-main-commands").classList.remove("hidden");
                        }, isDisabled, titleText, "submenu");
                    }
                });
                adicionarEscolha("<i class='fas fa-arrow-left mr-2'></i>Voltar", () => {
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    if (game.batalha.emBatalha) mostrarMensagem(`Turno do jogador. O que deseja fazer?`);
                }, false, "Voltar para as ações principais", "submenu");
            }

            function usarPocaoMenu() {
                if (game.batalha.tipoDesafioLorde === "lorde_exercito") {
                    mostrarMensagem("Poções estão seladas neste desafio!");
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    habilitarBotoesAcaoBatalha();
                    return;
                }
                if (game.batalha.isBossBattle && !game.batalha.monstro.isLordeDaMorte) {
                    mostrarMensagem("Não é possível usar poções durante uma batalha de chefe (exceto Lorde da Morte)!"); return;
                }
                const pocaoItens = game.player.inventario.filter(i => i.isPotion && i.quantity > 0);
                if (pocaoItens.length === 0) {
                    mostrarMensagem("Você não tem poções no inventário."); return;
                }

                mostrarMensagem("Escolha a poção para usar:");
                const submenu = document.getElementById("battle-submenu-choices");
                submenu.innerHTML = "";

                pocaoItens.forEach(pocaoStack => {
                    adicionarEscolha(`<span class="math-inline">\{pocaoStack\.nome\} \(x</span>{pocaoStack.quantity})`, () => {
                        usarPocao(pocaoStack);
                        document.getElementById("battle-submenu-choices").innerHTML = "";
                        document.getElementById("battle-submenu-choices").classList.add("hidden");
                        document.getElementById("battle-main-commands").classList.remove("hidden");
                    }, false, pocaoStack.descricao, "submenu");
                });
                adicionarEscolha("<i class='fas fa-arrow-left mr-2'></i>Voltar", () => {
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    if (game.batalha.emBatalha) mostrarMensagem(`Turno do jogador. O que deseja fazer?`);
                }, false, "Voltar para as ações principais", "submenu");
            }


            function usarPocao(pocaoStack) {
                if (game.batalha.isBossBattle && !game.batalha.monstro.isLordeDaMorte) { return; }
                if (!pocaoStack || pocaoStack.quantity <= 0) { return; }
                if (game.batalha.monstro?.isArquiteto && game.batalha.arquitetoBattleRefused) {
                    mostrarMensagem("Contra o Arquiteto, após recusar sua oferta, apenas sua arma básica responde. Poções, habilidades e fuga são inúteis.");
                    // Ensure main battle commands are visible if submenu was open
                    document.getElementById("battle-submenu-choices").innerHTML = "";
                    document.getElementById("battle-submenu-choices").classList.add("hidden");
                    document.getElementById("battle-main-commands").classList.remove("hidden");
                    return;
                }
                const curaVida = Math.floor(game.player.vidaMax * pocaoStack.curaVidaPct);
                const curaMana = Math.floor(game.player.manaMax * pocaoStack.curaManaPct);
                game.player.vidaAtual = Math.min(game.player.vidaAtual + curaVida, game.player.vidaMax);
                game.player.manaAtual = Math.min(game.player.manaAtual + curaMana, game.player.manaMax);
                pocaoStack.quantity--;
                if (pocaoStack.quantity <= 0) game.player.inventario = game.player.inventario.filter(i => i !== pocaoStack);

                let potionUseMessage = `Você usou <span class="font-bold text-sky-400">${pocaoStack.nome}</span> e recuperou ${curaVida} de vida e ${curaMana} de mana.`;
                let shadowAttackMsg = "";

                if (game.player.sombraAtiva && game.batalha.monstro.vidaAtual > 0 && game.player.sombraAtiva.statsAtuais) {
                    const sombra = game.player.sombraAtiva;
                    const danoSombra = Math.max(1, sombra.statsAtuais.danoBase + rankToIndex(sombra.rankSombra));
                    game.batalha.monstro.vidaAtual -= danoSombra;
                    if (game.batalha.monstro.vidaAtual < 0) game.batalha.monstro.vidaAtual = 0;
                    shadowAttackMsg = `<br/>Sua <span class="text-purple-300">${sombra.nomeSombra}</span> ataca, causando <span class="font-bold text-violet-400">${danoSombra}</span> de dano! Vida do monstro: ${monstro.vidaAtual} / ${monstro.vidaMax}.`;
                    potionUseMessage += shadowAttackMsg;

                    if (game.batalha.monstro.vidaAtual <= 0) {
                        mostrarMensagem(potionUseMessage);
                        updatePlayerBattleDisplay();
                        updateEnemyBattleDisplay(game.batalha.monstro);
                        updateSummonBattleDisplay();
                        atualizarInventarioTela();
                        setTimeout(() => { showBattleInterface(false); derrotarMonstro(game.batalha.monstro); }, 1200);
                        return;
                    }
                }

                mostrarMensagem(potionUseMessage + `<br/><br/>O ${game.batalha.monstro.nome} se prepara para atacar!`);

                updatePlayerBattleDisplay();
                updateEnemyBattleDisplay(game.batalha.monstro);
                updateSummonBattleDisplay();
                atualizarInventarioTela();
                atualizarStatusAtributos();

                game.batalha.jogadorAgiuNoTurno = true;
                desabilitarBotoesAcaoBatalha();
                setTimeout(() => monstroAtaca(), 1200);

            }


            function monstroAtaca() {
                if (!game.batalha.emBatalha || !game.batalha.monstro) return;
                decrementarBuffs(); // Decrementa a duração dos buffs do jogador
                const monstro = game.batalha.monstro;
                let msg = "";
                let targetPlayer = true; // Define se o ataque é para o jogador ou sombra

                // --- Processar DoTs (Damage over Time) no monstro ---
                if (monstro.activeDots && monstro.activeDots.length > 0) {
                    let dotsToRemove = [];
                    let totalDotDamage = 0;
                    monstro.activeDots.forEach(dot => {
                        monstro.vidaAtual -= dot.danoPorTurno;
                        totalDotDamage += dot.danoPorTurno;
                        dot.duracao--;
                        if (dot.duracao <= 0) {
                            dotsToRemove.push(dot);
                        }
                    });
                    if (totalDotDamage > 0) {
                        msg += `<span class="font-bold text-rose-500">O ${monstro.nome} sofre ${totalDotDamage} de dano</span> de efeitos persistentes!`;
                        if (monstro.vidaAtual < 0) monstro.vidaAtual = 0;
                    }
                    monstro.activeDots = monstro.activeDots.filter(dot => !dotsToRemove.includes(dot));
                    if (monstro.vidaAtual <= 0) { // Se o monstro morrer de DoT, a batalha termina aqui
                        mostrarMensagem(msg + `<br/>O ${monstro.nome} sucumbiu aos ferimentos!`); // Adiciona mensagem final do DoT
                        updateEnemyBattleDisplay(monstro);
                        updatePlayerBattleDisplay();
                        updateSummonBattleDisplay(); // Adicionado para consistência
                        setTimeout(() => { showBattleInterface(false); derrotarMonstro(monstro); }, 1200);
                        return;
                    }
                }

                // --- Processar Atordoamento do monstro ---
                // MODIFICADO: Melhorar a lógica de stunDuration para Time Stop e outros stuns
                if (monstro.isStunned && monstro.stunDuration && monstro.stunDuration > 0) {
                    monstro.stunDuration--;
                    let stunMsgPart = "está atordoado";
                    if (monstro.activeDebuffs?.find(d => d.tipo === "enemy_stun_turns")) { // Checa se é o Time Stop
                        stunMsgPart = `está paralisado pelo efeito de Time Stop (${monstro.stunDuration} turno(s) restantes)`;
                    } else if (monstro.stunDuration > 0) {
                        stunMsgPart = `está atordoado (${monstro.stunDuration} turno(s) restantes)`;
                    }
                    msg += `<br/>O ${monstro.nome} ${stunMsgPart} e perdeu o turno!`;

                    if (monstro.stunDuration <= 0) {
                        monstro.isStunned = false;
                        // stunDuration já é 0 ou menos, não precisa resetar para 0 explicitamente aqui.
                        // Remove o debuff de stun específico se houver
                        if (monstro.activeDebuffs) {
                            monstro.activeDebuffs = monstro.activeDebuffs.filter(d => d.tipo !== "enemy_stun_turns" && d.tipo !== "chance_atordoar");
                        }
                    }
                    // Se atordoado, pule o ataque do monstro
                    msg += `<br/><br/>Sua vez!`; // Passa a vez para o jogador
                    mostrarMensagem(msg);
                    updatePlayerBattleDisplay();
                    updateEnemyBattleDisplay(monstro);
                    updateSummonBattleDisplay();
                    atualizarStatusAtributos();
                    game.batalha.jogadorAgiuNoTurno = false;
                    habilitarBotoesAcaoBatalha();
                    return; // Termina o turno do monstro aqui
                }
                // Resetar isStunned se stunDuration chegou a zero em um turno anterior e não foi resetado
                if (monstro.isStunned && (!monstro.stunDuration || monstro.stunDuration <= 0)) {
                    monstro.isStunned = false;
                    if (monstro.activeDebuffs) { // Limpa qualquer debuff de stun restante
                        monstro.activeDebuffs = monstro.activeDebuffs.filter(d => d.tipo !== "enemy_stun_turns" && d.tipo !== "chance_atordoar");
                    }
                }

                // --- Processar Debuffs no monstro (aplicar antes do cálculo de dano) ---
                let tempDanoFisicoMonstro = monstro.danoFisico;
                let tempDanoMagicoMonstro = monstro.danoMagico;
                let tempPrecisaoMonstro = 1.0; // Assume 100% de precisão base

                if (monstro.activeDebuffs && monstro.activeDebuffs.length > 0) {
                    let debuffsToRemove = [];
                    monstro.activeDebuffs.forEach(debuff => {
                        if (debuff.tipo === "debuff_precisao_inimigo") {
                            tempPrecisaoMonstro -= debuff.valor; // Reduz a precisão
                        } else if (debuff.tipo === "debuff_defesa_inimigo") {
                            // Este debuff no monstro significa que ELE toma mais dano,
                            // não que ele causa menos. O cálculo de dano RECEBIDO pelo monstro
                            // já deveria considerar isso se implementado do lado do jogador.
                            // Aqui, não afeta o dano QUE O MONSTRO CAUSA.
                        } else if (debuff.tipo === "debuff_agilidade_inimigo") {
                            // Pode afetar a chance do monstro de esquivar ou a precisão do jogador contra ele.
                            // Não afeta diretamente o dano que o monstro causa.
                        }
                        debuff.duracao--;
                        if (debuff.duracao <= 0) {
                            debuffsToRemove.push(debuff);
                            msg += `<br/>O efeito de ${debuff.nomeSkill || 'debuff'} em ${monstro.nome} terminou.`;
                        }
                    });
                    monstro.activeDebuffs = monstro.activeDebuffs.filter(debuff => !debuffsToRemove.includes(debuff));
                }
                tempPrecisaoMonstro = Math.max(0.1, tempPrecisaoMonstro); // Garante chance mínima de acerto


                // Lógica de ataque do monstro
                if (monstro.isLordeDaMorteDesafio && game.batalha.tipoDesafioLorde === "lorde_dominio") {
                    let lordeAgiu = false;
                    if (monstro.copiaRecipienteSombras && monstro.copiaRecipienteSombras.length > 0 && !monstro.sombraAtivaCopiada && Math.random() < 0.5) {
                        const skillLordeInvocar = monstro.habilidadesLorde?.find(h => h.efeito.tipo === "lorde_invoca_sombra_copiada");
                        if (skillLordeInvocar && monstro.manaAtual >= skillLordeInvocar.manaBase) {
                            monstro.manaAtual -= skillLordeInvocar.manaBase;
                            const sombraParaInvocarPeloLorde = monstro.copiaRecipienteSombras.shift();

                            const vidaSombraLorde = Math.max(1, Math.floor(sombraParaInvocarPeloLorde.statsOriginais.vidaMax * 0.5));
                            const danoSombraLorde = Math.max(1, Math.floor((sombraParaInvocarPeloLorde.statsOriginais.danoFisico || 0) * 0.5));
                            monstro.sombraAtivaCopiada = {
                                ...sombraParaInvocarPeloLorde,
                                statsAtuais: { vidaMax: vidaSombraLorde, vidaAtual: vidaSombraLorde, danoBase: danoSombraLorde }
                            };
                            msg += (msg ? "<br/>" : "") + `O <span class="font-bold text-purple-600">${monstro.nome}</span> comanda uma <span class="text-violet-400">${monstro.sombraAtivaCopiada.nomeSombra}</span> das suas próprias fileiras para atacá-lo!`;
                            lordeAgiu = true;
                        }
                    }

                    if (monstro.sombraAtivaCopiada && monstro.sombraAtivaCopiada.statsAtuais.vidaAtual > 0) {
                        const sombraDoLorde = monstro.sombraAtivaCopiada;
                        let danoCausadoPelaSombraDoLorde = Math.max(1, sombraDoLorde.statsAtuais.danoBase + rankToIndex(sombraDoLorde.rankSombra));
                        danoCausadoPelaSombraDoLorde = calcularDanoRecebido(danoCausadoPelaSombraDoLorde); // Jogador recebe dano
                        game.player.vidaAtual -= danoCausadoPelaSombraDoLorde;
                        if (game.player.vidaAtual < 0) game.player.vidaAtual = 0;
                        msg += (lordeAgiu || msg ? "<br/>" : "") + `A <span class="text-violet-400">${sombraDoLorde.nomeSombra}</span> do Lorde ataca, causando <span class="font-bold text-rose-500">${danoCausadoPelaSombraDoLorde}</span> de dano.`;
                        lordeAgiu = true; // Marcar que uma ação ocorreu
                    }

                    const danoMonstroBase = tempDanoFisicoMonstro; // Usa dano físico ajustado por debuffs
                    const danoRecebidoJogador = calcularDanoRecebido(danoMonstroBase);
                    game.player.vidaAtual -= danoRecebidoJogador;
                    if (game.player.vidaAtual < 0) game.player.vidaAtual = 0;
                    msg += (lordeAgiu || msg ? "<br/>" : "") + `O <span class="font-bold text-purple-600">${monstro.nome}</span> ataca impiedosamente, causando <span class="font-bold text-rose-500">${danoRecebidoJogador}</span> de dano.`;
                    msg += `<br/>Sua vida: ${game.player.vidaAtual} / ${game.player.vidaMax}.`;

                } else if (monstro.isDesafioClasseBoss) {
                    let skillUsadaPeloBoss = null;
                    if (monstro.habilidades && monstro.habilidades.length > 0) {
                        const skillsDisponiveisParaBoss = monstro.habilidades.filter(h =>
                            (calcularGastoManaParaBoss(h, monstro)) <= monstro.manaAtual
                        );

                        if (skillsDisponiveisParaBoss.length > 0) {
                            skillUsadaPeloBoss = randomChoice(skillsDisponiveisParaBoss);
                        }
                    }

                    if (skillUsadaPeloBoss) {
                        const custoManaBoss = calcularGastoManaParaBoss(skillUsadaPeloBoss, monstro);
                        monstro.manaAtual -= custoManaBoss;

                        let danoBossSkillTotal = 0;
                        const numeroDeHitsBoss = skillUsadaPeloBoss.hits || 1;
                        let logHitsBossArray = [];

                        for (let i = 0; i < numeroDeHitsBoss; i++) {
                            let danoHitAtualBoss = 0;
                            if (skillUsadaPeloBoss.danoBase) {
                                danoHitAtualBoss = Math.floor((skillUsadaPeloBoss.danoBase +
                                    (skillUsadaPeloBoss.tipoDano === "magico" ? tempDanoMagicoMonstro : tempDanoFisicoMonstro * 0.7)) * 0.75);
                            } else if (skillUsadaPeloBoss.danoMultiplicador) {
                                danoHitAtualBoss = Math.floor(tempDanoFisicoMonstro * skillUsadaPeloBoss.danoMultiplicador * 0.75);
                            } else {
                                danoHitAtualBoss = Math.floor(tempDanoFisicoMonstro * 0.5);
                            }
                            danoHitAtualBoss = Math.max(1, danoHitAtualBoss);
                            logHitsBossArray.push(danoHitAtualBoss);
                            danoBossSkillTotal += danoHitAtualBoss;
                        }

                        const danoRecebidoJogador = calcularDanoRecebido(danoBossSkillTotal);
                        game.player.vidaAtual -= danoRecebidoJogador;
                        if (game.player.vidaAtual < 0) game.player.vidaAtual = 0;

                        msg = (msg ? msg + "<br/>" : "") + `O <span class="font-bold text-purple-400">${monstro.nome}</span> conjura <span class="font-bold text-sky-400">${skillUsadaPeloBoss.nome}</span>!`;
                        if (numeroDeHitsBoss > 1) {
                            msg += ` Atinge ${numeroDeHitsBoss} vezes, causando ${logHitsBossArray.join(' + ')} = <span class="font-bold text-rose-500">${danoRecebidoJogador}</span> de dano em você.`;
                        } else {
                            msg += ` Causa <span class="font-bold text-rose-500">${danoRecebidoJogador}</span> de dano em você.`;
                        }
                        if (custoManaBoss > 0) msg += `<br/>Mana do Eco: ${monstro.manaAtual} / ${monstro.manaMax}.`;

                    } else {
                        const danoRecebidoJogador = calcularDanoRecebido(tempDanoFisicoMonstro);
                        game.player.vidaAtual -= danoRecebidoJogador;
                        if (game.player.vidaAtual < 0) game.player.vidaAtual = 0;
                        msg = (msg ? msg + "<br/>" : "") + `O <span class="font-bold text-purple-400">${monstro.nome}</span> ataca fisicamente, causando <span class="font-bold text-rose-500">${danoRecebidoJogador}</span> de dano.<br/>Sua vida: ${game.player.vidaAtual} / ${game.player.vidaMax}.`;
                    }
                } else { // Monstro normal
                    if (game.player.sombraAtiva && game.player.sombraAtiva.statsAtuais && game.player.sombraAtiva.statsAtuais.vidaAtual > 0) {
                        if (Math.random() < 0.4) {
                            targetPlayer = false;
                        }
                    }

                    if (Math.random() > tempPrecisaoMonstro) { // Monstro errou (tempPrecisaoMonstro já foi ajustado por debuffs)
                        msg = (msg ? msg + "<br/>" : "") + `O <span class="font-bold text-rose-400">${monstro.nome}</span> tentou atacar, mas errou!`;
                    } else { // Monstro acertou
                        const ataqueMagicoMonstro = !monstro.isBoss && tempDanoMagicoMonstro > 0 && Math.random() < 0.4;
                        let danoMonstroBase = ataqueMagicoMonstro ? tempDanoMagicoMonstro : tempDanoFisicoMonstro;

                        if (monstro.isBoss) { // Lógica de dano para Bosses normais (não desafio)
                            if (tempDanoFisicoMonstro > (tempDanoMagicoMonstro || 0)) {
                                danoMonstroBase = tempDanoFisicoMonstro + (Math.random() < 0.3 ? randomInt(0, Math.floor((tempDanoMagicoMonstro || tempDanoFisicoMonstro * 0.2) * 0.5)) : 0);
                            } else {
                                danoMonstroBase = (tempDanoMagicoMonstro || 0) + (Math.random() < 0.3 ? randomInt(0, Math.floor(tempDanoFisicoMonstro * 0.5)) : 0);
                            }
                            danoMonstroBase = Math.max(1, danoMonstroBase, tempDanoFisicoMonstro, (tempDanoMagicoMonstro || 0));
                        }

                        if (targetPlayer) {
                            const danoRecebidoJogador = calcularDanoRecebido(danoMonstroBase);
                            game.player.vidaAtual -= danoRecebidoJogador;
                            if (game.player.vidaAtual < 0) game.player.vidaAtual = 0;
                            msg = (msg ? msg + "<br/>" : "") + `O <span class="font-bold text-rose-400">${monstro.nome}</span> atacou você com ${monstro.isBoss ? (monstro.isLordeDaMorte ? "um golpe da morte" : "um golpe devastador") : (ataqueMagicoMonstro ? "magia sombria" : "um ataque físico")} e causou <span class="font-bold text-rose-500">${danoRecebidoJogador}</span> de dano.<br/>Sua vida: ${game.player.vidaAtual} / ${game.player.vidaMax}`;
                        } else { // Alvo é a sombra
                            const sombra = game.player.sombraAtiva;
                            const danoSombraRecebido = Math.max(1, danoMonstroBase); // Sombra não tem resistenciaPct
                            sombra.statsAtuais.vidaAtual -= danoSombraRecebido;
                            msg = (msg ? msg + "<br/>" : "") + `O <span class="font-bold text-rose-400">${monstro.nome}</span> atacou sua <span class="text-purple-300">${sombra.nomeSombra}</span> causando <span class="font-bold text-orange-400">${danoSombraRecebido}</span> de dano.`;
                            if (sombra.statsAtuais.vidaAtual <= 0) {
                                sombra.statsAtuais.vidaAtual = 0;
                                msg += `<br/>Sua <span class="text-purple-300">${sombra.nomeSombra}</span> foi destruída!`;
                                game.player.sombraAtiva = null;
                            } else {
                                msg += `<br/>Vida da <span class="text-purple-300">${sombra.nomeSombra}</span>: ${sombra.statsAtuais.vidaAtual} / ${sombra.statsAtuais.vidaMax}.`;
                            }
                        }
                    }
                }

                if (game.player.vidaAtual <= 0) {
                    if (game.player.classe === "Necromante" &&
                        game.player.recipienteSombras.length > 0 &&
                        !game.batalha.isDesafioClasse &&
                        !(game.batalha.monstro && game.batalha.monstro.isLordeDaMorteDesafio)) {

                        const sombraSacrificada = game.player.recipienteSombras.shift();
                        game.player.vidaAtual = Math.floor(game.player.vidaMax * 0.5);
                        if (game.player.sombraAtiva) {
                            msg += `<br/>Sua sombra ativa, ${game.player.sombraAtiva.nomeSombra}, se dissipa com o golpe fatal!`;
                            game.player.sombraAtiva = null;
                        }
                        game.player.activeBuffs = [];

                        msg += `<br/><br/><span class="font-bold text-purple-500 animate-pulse">TRAIÇÃO DA MORTE!</span> Quando a escuridão o reivindicava, <span class="text-purple-300">${sombraSacrificada.nomeSombra} (Rank ${sombraSacrificada.rankSombra})</span> se desfez, rasgando sua alma de volta ao mundo dos vivos! Você retorna com 50% da vida. A sombra se foi para sempre.`;
                        msg += `<br/>A batalha termina abruptamente. Você se sente fraco, mas vivo.`;

                        mostrarMensagem(msg);

                        game.batalha.emBatalha = false;
                        game.monstroAtual = null;
                        showBattleInterface(false);
                        toggleHeaderNavButtons(false);
                        toggleChatInput(false);

                        atualizarRecipienteSombrasTela();
                        updatePlayerBattleDisplay();
                        updateSummonBattleDisplay();
                        atualizarStatusAtributos();

                        setTimeout(() => {
                            mostrarMensagem(msg + "<br/><br/>Você foi levado à tela de atributos para se recompor.");
                            abrirAtributos();
                        }, 3500);
                        return;

                    } else {
                        msg += (msg ? "<br/>" : "") + (game.batalha.isDesafioClasse ? "<br/><br/>Você falhou no desafio..." :
                            (game.batalha.monstro && game.batalha.monstro.isLordeDaMorteDesafio ? "<br/><br/>O Lorde da Morte provou ser demais para você desta vez..." : "<br/><br/>Você foi derrotado!"));
                        mostrarMensagem(msg);
                        updatePlayerBattleDisplay();
                        updateSummonBattleDisplay(); // Atualiza display da sombra também na derrota
                        setTimeout(() => {
                            showBattleInterface(false);
                            if (game.batalha.isDesafioClasse) {
                                falharDesafioHabilidade();
                            } else if (game.batalha.monstro && game.batalha.monstro.isLordeDaMorteDesafio) {
                                falharDesafioLordeDaMorte();
                            } else {
                                gameOver();
                            }
                        }, 1500);
                        return;
                    }
                }

                msg += `<br/><br/>Sua vez!`;
                mostrarMensagem(msg);

                updatePlayerBattleDisplay();
                updateEnemyBattleDisplay(monstro);
                updateSummonBattleDisplay();
                atualizarStatusAtributos();
                game.batalha.jogadorAgiuNoTurno = false;
                habilitarBotoesAcaoBatalha();

                document.getElementById("battle-submenu-choices").innerHTML = "";
                document.getElementById("battle-submenu-choices").classList.add("hidden");
                document.getElementById("battle-main-commands").classList.remove("hidden");
            }

            function verificarDesbloqueioHabilidadesClasse() {
                if (!game.player.classe) return [];
                const classeAtual = CLASSES_DATA[game.player.classe];
                if (!classeAtual || !classeAtual.habilidades) return [];

                let notificacoesParaMensagemDeLevelUp = [];

                classeAtual.habilidades.forEach(skill => {
                    const isAcquired = game.player.magiasAdquiridas.includes(skill.id);
                    const playerLevelOk = game.player.nivel >= skill.unlockLevel;

                    if (!isAcquired) {
                        let lockReason = "";
                        let isEffectivelyLocked = false;

                        // Necromancer specific initial skills handled by defeating Lord of Death
                        if (game.player.classe === "Necromante" && (skill.id === "n_extracao_sombras" || skill.id === "n_invocar_sombra")) {
                            if (!game.player.metLordeDaMorte) {
                                isEffectivelyLocked = true;
                                lockReason = "(Bloqueada - Derrote o Lorde da Morte)";
                            } else if (!playerLevelOk) {
                                isEffectivelyLocked = true;
                                lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel})`;
                            } else {
                                // This case means Lorde is met, level is met, but skill not acquired.
                                // It should have been auto-acquired by tentarDesbloquearNecromante.
                                // If not, it means the player either used a cheat that bypassed this, or
                                // something else prevented it. We'll mark it as available to learn manually if it somehow slipped.
                                notificacoesParaMensagemDeLevelUp.push(`Você pode aprender <span class="font-bold text-sky-400">${skill.nome}</span> (Nv. ${skill.unlockLevel})! Visite a tela de Habilidades.`);
                            }
                        }
                        // Challenge-based skills (including Necromancer's advanced ones)
                        else if (skill.requerDesafio) {
                            if (game.player.classe === "Necromante" && (skill.id === "n_dominio_sombras" || skill.id === "n_exercito_sombras")) {
                                if (!game.player.metLordeDaMorte) {
                                    isEffectivelyLocked = true;
                                    lockReason = "(Bloqueada - Derrote o Lorde da Morte para liberar o desafio)";
                                } else if (!playerLevelOk) {
                                    isEffectivelyLocked = true;
                                    lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel} para liberar o desafio)`;
                                } else {
                                    notificacoesParaMensagemDeLevelUp.push(`Um desafio para dominar <span class="font-bold text-yellow-400">${skill.nome}</span> (Nv. ${skill.unlockLevel}) está agora disponível! Visite a tela de Habilidades.`);
                                }
                            } else { // General challenge skills for other classes
                                if (!playerLevelOk) {
                                    isEffectivelyLocked = true;
                                    lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel})`;
                                } else {
                                    notificacoesParaMensagemDeLevelUp.push(`Um desafio para dominar <span class="font-bold text-yellow-400">${skill.nome}</span> (Nv. ${skill.unlockLevel}) está agora disponível! Visite a tela de Habilidades.`);
                                }
                            }
                        }
                        // Skills that unlock purely by level (not requiring challenge and not initial Necromancer skills)
                        else if (playerLevelOk) {
                            notificacoesParaMensagemDeLevelUp.push(`Você pode aprender <span class="font-bold text-sky-400">${skill.nome}</span>! Visite a tela de Habilidades.`);
                        }
                    }
                });
                return notificacoesParaMensagemDeLevelUp;
            }
            function derrotarMonstro(monstro) {
                const eraDesafioClasse = game.batalha.isDesafioClasse;
                const skillDesafiadaId = game.batalha.skillEmDesafioId;
                const eraDesafioLorde = game.batalha.monstro?.isLordeDaMorteDesafio; // Check if it was a Lorde challenge
                const tipoDesafioLordeVencido = game.batalha.tipoDesafioLorde;     // Store type before reset

                showBattleInterface(false);
                game.batalha.emBatalha = false;
                game.batalha.isDesafioClasse = false;
                game.batalha.skillEmDesafioId = null;
                game.batalha.desafioBossOriginalStats = null;
                game.batalha.tipoDesafioLorde = null; // Reset Lorde challenge type

                if (game.player.classe === "Necromante" && !monstro.isBoss && !eraDesafioClasse && !eraDesafioLorde && game.player.magiasAdquiridas.includes("n_extracao_sombras")) {
                    game.player.lastDefeatedMonsterInfo = {
                        nome: monstro.nome, rank: monstro.rank,
                        vidaMax: monstro.vidaMax, danoFisico: monstro.danoFisico, danoMagico: monstro.danoMagico,
                    };
                } else {
                    game.player.lastDefeatedMonsterInfo = null;
                }
                if (game.player.sombraAtiva) game.player.sombraAtiva = null; // Sombra always dissipates after any battle for now

                let xpGanhoBase = monstro.xpGanho;
                let xpFinal = Math.floor(xpGanhoBase * (1 + game.player.xpBonus));
                // --- Marcado XP Benefit ---
                if (game.player.isMarcado) {
                    xpFinal *= 2;
                }
                // --- End Marcado XP Benefit ---
                let moedasGanhas = 0;

                if (!eraDesafioClasse && !eraDesafioLorde) {
                    moedasGanhas = randomInt(5, 20) * (rankToIndex(monstro.rank) + 1) * (monstro.isBoss ? 5 : 1);
                    game.player.moedas += moedasGanhas;
                } else if (eraDesafioLorde) {
                    // XP for Lorde challenge is already set in its stats from gerarLordeDaMorteParaDesafio
                    // Moedas for Lorde challenge can be specific if desired, or 0
                    // moedasGanhas = 200; // Example fixed coins for Lorde challenge
                    // game.player.moedas += moedasGanhas;
                } else if (eraDesafioClasse) {
                    // XP for class challenge is set in gerarBossDesafioClasse
                    // moedasGanhas = 50; // Example fixed coins for class challenge
                    // game.player.moedas += moedasGanhas;
                }

                game.player.xp += xpFinal;

                for (const attr in game.player.atributos) {
                    game.player.atributos[attr] = +(game.player.atributos[attr] + 0.1).toFixed(1);
                }
                game.player.vidaAtual = Math.min(game.player.vidaAtual + Math.floor(game.player.vidaMax * 0.3), game.player.vidaMax);
                game.player.manaAtual = Math.min(game.player.manaAtual + Math.floor(game.player.manaMax * 0.3), game.player.manaMax);
                game.player.activeBuffs = [];

                let itensDropadosParaMensagem = [];
                if (!eraDesafioClasse && !eraDesafioLorde) { // No item drops from challenges
                    const dropChance = monstro.isBoss ? 1.0 : 0.7;
                    if (Math.random() < dropChance) {
                        const numeroDeItensADropar = monstro.isBoss ? 3 : 1;
                        const rankIndexMonstroBase = rankToIndex(monstro.rank);
                        for (let i = 0; i < numeroDeItensADropar; i++) {
                            let itemRankForDropIndex = rankIndexMonstroBase;
                            if (!monstro.isBoss) {
                                const roll = Math.random();
                                if (roll < 0.15) itemRankForDropIndex = Math.min(RANKS.length - 1, rankIndexMonstroBase + 1);
                                else if (roll < 0.70) itemRankForDropIndex = rankIndexMonstroBase;
                                else itemRankForDropIndex = Math.max(0, rankIndexMonstroBase - 1);
                            } else {
                                const bossItemRoll = Math.random();
                                if (bossItemRoll < 0.20 && rankIndexMonstroBase > 0) itemRankForDropIndex = rankIndexMonstroBase - 1;
                                else if (bossItemRoll < 0.40 && rankIndexMonstroBase < RANKS.length - 1) itemRankForDropIndex = rankIndexMonstroBase + 1;
                                itemRankForDropIndex = clamp(itemRankForDropIndex, 0, RANKS.length - 1);
                            }
                            const rankItem = indexToRank(itemRankForDropIndex);
                            const itemGerado = gerarItem(rankItem);
                            if (itemGerado) {
                                addItemToInventory(itemGerado);
                                itensDropadosParaMensagem.push(`${itemGerado.nome} (Rank ${itemGerado.rank})`);
                            }
                        }
                    }
                }

                let leveledUp = false;
                let levelUpMessages = [];
                while (game.player.xp >= game.player.xpProximoNivel) {
                    leveledUp = true; game.player.xp -= game.player.xpProximoNivel; game.player.nivel++;
                    game.player.pontosDistribuir += 5;
                    for (const attr in game.player.atributos) { game.player.atributos[attr] = +(game.player.atributos[attr] + 1).toFixed(1); }
                    levelUpMessages.push(`Você subiu para o nível <span class="font-bold text-emerald-400">${game.player.nivel}</span>, ganhou 5 pontos para distribuir e +1 em todos os atributos!`);
                    game.player.xpProximoNivel = Math.floor(game.player.xpProximoNivel * 1.30);
                    atualizarMercadorVisibilidade();
                    atualizarRank();
                    const novasSkillsMsgsNotificacao = verificarDesbloqueioHabilidadesClasse();
                    levelUpMessages = levelUpMessages.concat(novasSkillsMsgsNotificacao);
                }
                atualizarAtributosDerivados();

                let msg = "";
                if (eraDesafioLorde) { // Specific message for Lorde da Morte Challenge
                    const skillAprendidaObj = CLASSES_DATA.Necromante.habilidades.find(h => h.id === skillDesafiadaId); // skillDesafiadaId was stored
                    if (skillAprendidaObj) {
                        if (!game.player.magiasAdquiridas.includes(skillDesafiadaId)) {
                            game.player.magiasAdquiridas.push(skillDesafiadaId);
                        }
                        msg = `<span class="font-bold text-yellow-300 animate-ping">PODER DESBLOQUEADO!</span><br/>Você superou o Lorde da Morte (${tipoDesafioLordeVencido === "lorde_dominio" ? "Desafio de Domínio" : "Desafio de Exército"}) e dominou <span class="font-bold text-sky-300">${skillAprendidaObj.nome}</span>!`;
                        if (game.player.magiasEquipadas.length < 4 && !game.player.magiasEquipadas.includes(skillDesafiadaId)) {
                            game.player.magiasEquipadas.push(skillDesafiadaId);
                            msg += ` A habilidade foi equipada automaticamente.`;
                        }
                    } else {
                        msg = `<span class="font-bold text-yellow-300">VITÓRIA SOBRE O LORDE!</span> Você sente seu domínio sobre as sombras se aprofundar!`;
                    }
                    msg += `<br/>Ganhou <span class="font-bold text-amber-400">${xpFinal}</span> XP${game.player.isMarcado ? " (Dobrado!)" : ""} pela árdua vitória.`;
                    if (moedasGanhas > 0) msg += ` e <span class="font-bold text-amber-300">${moedasGanhas}</span> moedas.`;

                } else if (eraDesafioClasse && skillDesafiadaId) {
                    const skillAprendidaObj = CLASSES_DATA[game.player.classe].habilidades.find(h => h.id === skillDesafiadaId);
                    if (skillAprendidaObj) {
                        if (!game.player.magiasAdquiridas.includes(skillDesafiadaId)) {
                            game.player.magiasAdquiridas.push(skillDesafiadaId);
                        }
                        msg = `<span class="font-bold text-green-400">Desafio Concluído!</span><br/>Você dominou <span class="font-bold text-sky-400">${skillAprendidaObj.nome}</span>!`;
                        if (game.player.magiasEquipadas.length < 4 && !game.player.magiasEquipadas.includes(skillDesafiadaId)) {
                            game.player.magiasEquipadas.push(skillDesafiadaId);
                            msg += ` Equipada automaticamente.`;
                        }
                    } else {
                        msg = `<span class="font-bold text-green-400">Desafio Concluído!</span><br/>Você sente um novo poder despertar!`;
                    }
                    msg += `<br/>Ganhou <span class="font-bold text-amber-400">${xpFinal}</span> XP${game.player.isMarcado ? " (Dobrado!)" : ""} pela vitória no desafio.`;
                    if (moedasGanhas > 0) msg += ` e <span class="font-bold text-amber-300">${moedasGanhas}</span> moedas.`;
                } else { // Normal monster defeat
                    msg = `Você derrotou o <span class="font-bold text-rose-400">${monstro.nome}</span>!<br/>Ganhou <span class="font-bold text-amber-400">${xpFinal}</span> XP${game.player.isMarcado ? " (Dobrado!)" : ""} e <span class="font-bold text-amber-300">${moedasGanhas}</span> moedas.`;
                    if (itensDropadosParaMensagem.length > 0) {
                        msg += `<br/><br/><span class="font-semibold text-amber-300">${monstro.isBoss ? "O Chefe deixou cair os seguintes tesouros:" : "O monstro deixou cair:"}</span>`;
                        itensDropadosParaMensagem.forEach(nomeItem => {
                            msg += `<br/>- <span class="font-bold text-sky-400">${nomeItem}</span>`;
                        });
                    } else if (monstro.isBoss && !eraDesafioClasse && !eraDesafioLorde) { // Only show no drop message for actual bosses, not challenges
                        msg += `<br/><br/>O Chefe não deixou cair nenhum item utilizável desta vez.`;
                    }
                }

                if (levelUpMessages.length > 0) msg += "<br/><br/>" + levelUpMessages.join("<br/>");

                if (eraDesafioLorde || eraDesafioClasse) { // Challenges have specific return paths
                    mostrarMensagem(msg + "<br/><br/>Você retorna fortalecido. O que deseja fazer?");
                    limparEscolhas();
                    adicionarEscolha("Ver Habilidades", abrirSkills);
                    adicionarEscolha("Continuar Aventura", abrirInicio);
                    atualizarStatusAtributos();
                    atualizarSkillsTela();
                    toggleHeaderNavButtons(false);
                    toggleChatInput(false);
                    updateGoogleSignInUI();
                    return;
                }

                // --- Monarch Encounter Chance after Dungeon Boss (moved from completarMasmorra) ---
                if (game.dungeon.active && monstro.isBoss && !monstro.isMonarchBoss && !monstro.isArquiteto && !monstro.isLordeDaMorte && !eraDesafioClasse && !eraDesafioLorde) { // Only after a true dungeon boss
                    if (rankToIndex(game.dungeon.typeRank) >= rankToIndex("B") && Math.random() < 0.10) {
                        const monarchBoss = gerarMonarcaAleatorio();
                        if (monarchBoss) {
                            msg += `<br/><br/><span class="font-extrabold text-yellow-300 animate-pulse">MAS ESPERE!</span> Assim que você pensou que a masmorra estava limpa, uma presença avassaladora emerge das ruínas do chefe derrotado! O <span class="font-bold text-red-500">${monarchBoss.nome}</span> está aqui!`;
                            mostrarMensagem(msg);
                            game.monstroAtual = monarchBoss;

                            // Dungeon is completed, but a new battle starts
                            game.dungeon.bossDefeated = true; // Mark dungeon boss as defeated
                            // game.dungeon.active = false; // Keep dungeon context for completingMasmorra, then reset
                            game.estado = "batalha";
                            game.batalha.isBossBattle = true;

                            setTimeout(() => {
                                toggleHeaderNavButtons(true);
                                toggleChatInput(true);
                                iniciarBatalha(monarchBoss); // This will set emBatalha to true
                            }, 3500);
                            updateGoogleSignInUI();
                            atualizarStatusAtributos();
                            return;
                        }
                    }
                }
                // --- End Monarch Encounter ---


                if (monstro.isLordeDaMorte) {
                    if (tentarDesbloquearNecromante(monstro)) {
                        const necroUnlockMsg = document.getElementById("story-text")?.innerHTML || "";
                        mostrarMensagem(msg + "<hr class='my-2 border-slate-600'>" + necroUnlockMsg);
                        // tentarDesbloquearNecromante handles its own UI and choices
                        return;
                    }
                }
                if (!game.player.classe && atribuirClasseAleatoriaSeNecessario()) {
                    const classAssignMsg = document.getElementById("story-text")?.innerHTML || "";
                    mostrarMensagem(msg + "<hr class='my-2 border-slate-600'>" + classAssignMsg);
                    // atribuirClasseAleatoriaSeNecessario handles its own UI and choices
                    return;
                }

                if (game.dungeon.active) {
                    if (monstro.isBoss) { // This means a regular dungeon boss was defeated (not Arquiteto, not Monarch spawned after)
                        completarMasmorra(msg); // Pass the accumulated message
                        return;
                    } else {
                        msg += `<br/><br/>Você avança para a próxima sala da masmorra...`;
                        mostrarMensagem(msg);
                        atualizarStatusAtributos();
                        setTimeout(() => { game.dungeon.currentRoom++; avancarSalaMasmorra(); }, 2000);
                        return;
                    }
                }

                // Standard post-battle (not challenge, not dungeon that returned early)
                toggleHeaderNavButtons(false);
                toggleChatInput(false);

                if (game.player.lastDefeatedMonsterInfo && game.player.classe === "Necromante" && game.player.magiasAdquiridas.includes("n_extracao_sombras")) {
                    msg += `<br/><br/><span class="text-purple-300">Você sente a essência do ${game.player.lastDefeatedMonsterInfo.nome} pronta para ser extraída...</span>`;
                }
                msg += `<br/><br/>O que deseja fazer?`;
                mostrarMensagem(msg);
                limparEscolhas();

                if (game.player.classe === "Necromante" && game.player.lastDefeatedMonsterInfo && game.player.magiasAdquiridas.includes("n_extracao_sombras")) {
                    const extracaoSkill = CLASSES_DATA.Necromante.habilidades.find(h => h.id === "n_extracao_sombras");
                    if (extracaoSkill) {
                        adicionarEscolha(`Usar ${extracaoSkill.nome} (Mana: ${calcularGastoMana(extracaoSkill)})`, () => {
                            const manaCost = calcularGastoMana(extracaoSkill);
                            if (game.player.manaAtual >= manaCost) {
                                game.player.manaAtual -= manaCost;
                                const lastMonster = game.player.lastDefeatedMonsterInfo;
                                const newRankIndex = Math.max(0, rankToIndex(lastMonster.rank) - 1);
                                const shadowRank = indexToRank(newRankIndex);
                                const shadowId = crypto.randomUUID();
                                const newShadow = { id: shadowId, nomeOriginal: lastMonster.nome, nomeSombra: `Sombra de ${lastMonster.nome}`, rankOriginal: lastMonster.rank, rankSombra: shadowRank, statsOriginais: { vidaMax: lastMonster.vidaMax, danoFisico: lastMonster.danoFisico, danoMagico: lastMonster.danoMagico } };

                                if (game.player.recipienteSombras.length < game.player.recipienteCapacity) {
                                    game.player.recipienteSombras.push(newShadow);
                                    game.player.lastDefeatedMonsterInfo = null;
                                    atualizarRecipienteSombrasTela();
                                    let msgExtracao = `Você extraiu a <span class="text-purple-300">${newShadow.nomeSombra}</span>! Ela foi adicionada ao seu Recipiente.<br/>Mana restante: ${game.player.manaAtual}/${game.player.manaMax}.<br/><br/>O que fazer agora?`;
                                    mostrarMensagem(msgExtracao);
                                } else {
                                    mostrarMensagem(`Seu Recipiente de Sombras está cheio (${game.player.recipienteSombras.length}/${game.player.recipienteCapacity}). Não foi possível extrair a sombra. Mana não gasta.`);
                                    game.player.manaAtual += manaCost; // Refund mana
                                }
                                limparEscolhas();
                                if (leveledUp) adicionarEscolha("Distribuir Atributos", abrirAtributos);
                                adicionarEscolha("Continuar explorando", explorarArea);
                                adicionarEscolha(`Entrar na Masmorra (Rank ${game.player.currentArea})`, () => entrarMasmorra(game.player.currentArea));
                                adicionarEscolha("Abrir habilidades", abrirSkills);
                                adicionarEscolha("Abrir inventário", abrirInventario);
                                if (game.player.nivel >= 10) adicionarEscolha("Mudar de Área", abrirTelaMudarArea);
                            } else {
                                mostrarMensagem(`Mana insuficiente para Extração de Sombras. (${manaCost} necessário).`);
                                // Re-add choices without the extraction one or keep it disabled
                                limparEscolhas();
                                if (leveledUp) adicionarEscolha("Distribuir Atributos", abrirAtributos);
                                adicionarEscolha("Continuar explorando", explorarArea);
                                adicionarEscolha(`Entrar na Masmorra (Rank ${game.player.currentArea})`, () => entrarMasmorra(game.player.currentArea));
                                adicionarEscolha("Abrir habilidades", abrirSkills);
                                adicionarEscolha("Abrir inventário", abrirInventario);
                                if (game.player.nivel >= 10) adicionarEscolha("Mudar de Área", abrirTelaMudarArea);
                            }
                            atualizarStatusAtributos();
                        }, game.player.manaAtual < calcularGastoMana(extracaoSkill), extracaoSkill.descricao);
                    }
                }
                if (leveledUp) adicionarEscolha("Distribuir Atributos", abrirAtributos);
                adicionarEscolha("Continuar explorando", explorarArea);
                adicionarEscolha(`Entrar na Masmorra (Rank ${game.player.currentArea})`, () => entrarMasmorra(game.player.currentArea));
                adicionarEscolha("Abrir habilidades", abrirSkills);
                adicionarEscolha("Abrir inventário", abrirInventario);
                if (game.player.nivel >= 10) adicionarEscolha("Mudar de Área", abrirTelaMudarArea);

                atualizarStatusAtributos();
                atualizarSkillsTela();
                updateGoogleSignInUI();
            }

            function gameOver() {
                showBattleInterface(false);
                toggleHeaderNavButtons(true);
                toggleChatInput(true);
                game.estado = "gameover";
                if (game.dungeon.active) { game.dungeon.active = false; game.batalha.isBossBattle = false; }
                if (isGoogleSignedIn) deleteSavedGameForGoogleUser();
                if (game.player.sombraAtiva) game.player.sombraAtiva = null;

                mostrarMensagem(`<span class="text-rose-600 font-extrabold text-3xl">Você morreu!</span><br/>O mundo de <span class="font-bold text-sky-400">Arkham</span> não foi gentil desta vez.<br/>Seu progresso salvo na nuvem (se houver) foi apagado.<br/><br/>Deseja recomeçar?`);
                limparEscolhas();
                adicionarEscolha("Recomeçar", () => iniciarJogo(true));
                updateGoogleSignInUI();
            }
            function falharDesafioHabilidade() {
                mostrarMensagem(`Você não conseguiu superar o desafio para dominar <span class="font-bold text-sky-400">${CLASSES_DATA[game.player.classe].habilidades.find(h => h.id === game.batalha.skillEmDesafioId)?.nome || "esta habilidade"}</span>.<br/>Tente novamente quando estiver mais forte.`);
                game.batalha.isDesafioClasse = false;
                game.batalha.skillEmDesafioId = null;
                game.batalha.desafioBossOriginalStats = null;
                game.batalha.emBatalha = false; // Garante que saiu do modo batalha
                // Restaurar uma pequena parte da vida/mana do jogador? (Opcional)
                // game.player.vidaAtual = Math.max(1, Math.floor(game.player.vidaMax * 0.25));
                // game.player.manaAtual = Math.max(0, Math.floor(game.player.manaMax * 0.25));
                atualizarStatusAtributos();

                limparEscolhas();
                adicionarEscolha("Retornar à tela de Habilidades", abrirSkills);
                adicionarEscolha("Voltar ao Início", abrirInicio);
                toggleHeaderNavButtons(false);
                toggleChatInput(false);
            }


            function abrirAtributos() {
                game.estado = "atributos";
                atualizarRank();
                atualizarAtributosDerivados();
                atualizarStatusAtributos();
                document.getElementById("game-screen")?.classList.add("hidden");
                document.getElementById("atributos-screen")?.classList.remove("hidden");
                document.getElementById("inventario-screen")?.classList.add("hidden");
                document.getElementById("mercador-screen")?.classList.add("hidden");
                document.getElementById("skills-screen")?.classList.add("hidden");
                atualizarTelaAtributos();
                updateGoogleSignInUI();
            }

            function atualizarTelaAtributos() {
                const a = game.player.atributos;
                document.getElementById("forca-val").textContent = a.forca.toFixed(1);
                document.getElementById("forca-rank").textContent = getAtributoRank(a.forca);

                document.getElementById("agilidade-val").textContent = a.agilidade.toFixed(1);
                document.getElementById("agilidade-rank").textContent = getAtributoRank(a.agilidade);

                document.getElementById("inteligencia-val").textContent = a.inteligencia.toFixed(1);
                document.getElementById("inteligencia-rank").textContent = getAtributoRank(a.inteligencia);

                document.getElementById("resistencia-val").textContent = a.resistencia.toFixed(1);
                document.getElementById("resistencia-rank").textContent = getAtributoRank(a.resistencia);

                document.getElementById("vitalidade-val").textContent = a.vitalidade.toFixed(1);
                document.getElementById("vitalidade-rank").textContent = getAtributoRank(a.vitalidade);

                document.getElementById("percepcao-val").textContent = a.percepcao.toFixed(1);
                document.getElementById("percepcao-rank").textContent = getAtributoRank(a.percepcao);

                document.getElementById("pontos-disponiveis").textContent = game.player.pontosDistribuir.toString();
                atualizarStatusAtributos();
            }


            function manipularBotaoAtributo(e) {
                const btn = e.target.closest(".btn-attr");
                const modeBtn = e.target.closest(".attribute-mode-btn");

                if (modeBtn) {
                    attributeAddAmount = parseInt(modeBtn.dataset.amount);
                    document.querySelectorAll('.attribute-mode-btn').forEach(b => b.classList.remove('active'));
                    modeBtn.classList.add('active');
                    return;
                }

                if (!btn) return;

                const attr = btn.dataset.attr;
                const action = btn.dataset.action;

                if (!attr || !action || !game.player.atributos.hasOwnProperty(attr)) return;

                const valAtual = parseFloat(game.player.atributos[attr]);

                if (action === "inc") {
                    const amountToSpend = attributeAddAmount; // How many points the player intends to spend
                    if (game.player.pontosDistribuir >= amountToSpend) {
                        // If Marcado, each point spent effectively gives 2 attribute points
                        const effectiveAttributeIncrease = game.player.isMarcado ? amountToSpend * 2 : amountToSpend;
                        game.player.atributos[attr] = +(valAtual + effectiveAttributeIncrease).toFixed(1);
                        game.player.pontosDistribuir -= amountToSpend; // Cost remains the points spent
                    } else {
                        alert(`Você não tem ${amountToSpend} ponto(s) de atributo para distribuir. Você tem ${game.player.pontosDistribuir} disponíveis.`);
                    }
                } else if (action === "dec") {
                    const pointsToRefund = 1; // Always refund 1 distribution point
                    // How much the actual attribute value should decrease when refunding 1 distribution point
                    const attributeValueDecrease = game.player.isMarcado ? 2 : 1;

                    // Check if we can decrease the attribute by its effective value without going below its base
                    if (valAtual - attributeValueDecrease >= BASE_STATS[attr]) {
                        game.player.atributos[attr] = +(valAtual - attributeValueDecrease).toFixed(1);
                        game.player.pontosDistribuir += pointsToRefund;
                    } else if (valAtual - 1 >= BASE_STATS[attr]) {
                        // Fallback: if the full effective decrease (e.g., -2 for Marcado) goes below base,
                        // but decreasing by 1 raw point is still valid, do that.
                        // This handles cases where a Marcado might have an odd stat point from non-Marcado increases
                        // or if an attribute was somehow set to just 1 above base while Marcado.
                        game.player.atributos[attr] = +(valAtual - 1).toFixed(1);
                        game.player.pontosDistribuir += pointsToRefund;
                    }
                    // Otherwise, the attribute is at its base or 1 above base for Marcado, and cannot be decreased further by this logic.
                }

                atualizarAtributosDerivados();
                atualizarTelaAtributos();
            }

            function salvarAtributos() {
                atualizarRank();
                atualizarAtributosDerivados();
                atualizarStatusAtributos();
                abrirInicio();
            }

            function abrirInicio() {
                toggleHeaderNavButtons(false);
                toggleChatInput(false);
                game.estado = "inicio";
                game.dungeon.active = false;
                game.dungeon.isBossRoomConfirmation = false;
                game.batalha.isBossBattle = false;
                if (!game.batalha.emBatalha) {
                    game.player.activeBuffs = [];
                }

                document.getElementById("game-screen")?.classList.remove("hidden");
                document.getElementById("atributos-screen")?.classList.add("hidden");
                document.getElementById("inventario-screen")?.classList.add("hidden");
                document.getElementById("mercador-screen")?.classList.add("hidden");
                document.getElementById("skills-screen")?.classList.add("hidden");

                if (game.player.metLordeDaMorte && !game.player.classe) {
                    const mockLorde = { isLordeDaMorte: true };
                    if (tentarDesbloquearNecromante(mockLorde)) return;
                }
                if (!game.player.classe && atribuirClasseAleatoriaSeNecessario()) {
                    return;
                }

                let inicioMsg = `Você está na <span class="font-bold text-sky-400">Área ${DUNGEON_CONFIG[game.player.currentArea].name}</span> do mundo de Arkham.<br/><br/>O que deseja fazer?`;
                if (game.player.lastDefeatedMonsterInfo && game.player.classe === "Necromante" && game.player.magiasAdquiridas.includes("n_extracao_sombras")) {
                    inicioMsg = `Você está na <span class="font-bold text-sky-400">Área ${game.player.currentArea}</span>. A essência do <span class="text-purple-300">${game.player.lastDefeatedMonsterInfo.nome}</span> ainda paira, pronta para extração.<br/><br/>O que deseja fazer?`;
                }

                mostrarMensagem(inicioMsg);
                limparEscolhas();

                if (game.player.classe === "Necromante" && game.player.lastDefeatedMonsterInfo && game.player.magiasAdquiridas.includes("n_extracao_sombras")) {
                    const extracaoSkill = CLASSES_DATA.Necromante.habilidades.find(h => h.id === "n_extracao_sombras");
                    if (extracaoSkill) {
                        adicionarEscolha(`Usar ${extracaoSkill.nome} (Mana: ${calcularGastoMana(extracaoSkill)})`, () => {
                            const manaCost = calcularGastoMana(extracaoSkill);
                            if (game.player.manaAtual >= manaCost) {
                                game.player.manaAtual -= manaCost;
                                const lastMonster = game.player.lastDefeatedMonsterInfo;
                                const newRankIndex = Math.max(0, rankToIndex(lastMonster.rank) - 1);
                                const shadowRank = indexToRank(newRankIndex);
                                const shadowId = crypto.randomUUID();
                                const newShadow = {
                                    id: shadowId, nomeOriginal: lastMonster.nome, nomeSombra: `Sombra de ${lastMonster.nome}`,
                                    rankOriginal: lastMonster.rank, rankSombra: shadowRank,
                                    statsOriginais: { vidaMax: lastMonster.vidaMax, danoFisico: lastMonster.danoFisico, danoMagico: lastMonster.danoMagico }
                                };
                                game.player.recipienteSombras.push(newShadow);
                                game.player.lastDefeatedMonsterInfo = null;
                                atualizarRecipienteSombrasTela();
                                atualizarStatusAtributos();
                                abrirInicio();
                            } else {
                                mostrarMensagem(`Mana insuficiente para Extração de Sombras. (${manaCost} necessário).`);
                                adicionarEscolha("Voltar", abrirInicio);
                            }
                        }, false, extracaoSkill.descricao);
                    }
                }

                adicionarEscolha("Explorar a área", explorarArea);
                adicionarEscolha(`Entrar na Masmorra (${DUNGEON_CONFIG[game.player.currentArea].name})`, () => entrarMasmorra(game.player.currentArea));
                adicionarEscolha("Ver atributos", abrirAtributos);
                adicionarEscolha("Abrir habilidades", abrirSkills);
                adicionarEscolha("Abrir inventário", abrirInventario);
                if (game.player.nivel >= 10) adicionarEscolha("Mudar de Área", abrirTelaMudarArea);

                updateGoogleSignInUI();
                atualizarStatusAtributos();
            }

            function abrirInventario() {
                game.estado = "inventario";
                document.getElementById("game-screen")?.classList.add("hidden");
                document.getElementById("atributos-screen")?.classList.add("hidden");
                document.getElementById("inventario-screen")?.classList.remove("hidden");
                document.getElementById("mercador-screen")?.classList.add("hidden");
                document.getElementById("skills-screen")?.classList.add("hidden");
                atualizarInventarioTela();
                atualizarRecipienteSombrasTela();
                updateGoogleSignInUI();
            }

            function atualizarRecipienteSombrasTela() {
                const containerDiv = document.getElementById("recipiente-sombras-container");
                const listaSombrasUL = document.getElementById("lista-sombras-recipiente");
                if (!containerDiv || !listaSombrasUL) return;
                listaSombrasUL.innerHTML = "";

                if (game.player.classe === "Necromante") {
                    containerDiv.classList.remove("hidden");

                    let hasContent = false;

                    // Display current active shadow
                    if (game.player.sombraAtiva) {
                        hasContent = true;
                        const sombra = game.player.sombraAtiva;
                        const liAtiva = document.createElement("li");
                        liAtiva.className = "bg-slate-500 border border-amber-500 rounded p-3 shadow-lg mb-3";

                        const ativaInfoDiv = document.createElement("div");
                        ativaInfoDiv.className = "flex flex-col sm:flex-row justify-between sm:items-center";

                        const ativaNomeSpan = document.createElement("span");
                        ativaNomeSpan.className = "font-bold text-amber-300 text-lg";
                        ativaNomeSpan.innerHTML = `${sombra.nomeSombra} <span class="text-sm font-normal text-amber-200">(Rank ${sombra.rankSombra})</span> - ATIVA`;
                        ativaInfoDiv.appendChild(ativaNomeSpan);

                        const ativaStatsSpan = document.createElement("span");
                        ativaStatsSpan.className = "text-xs text-amber-100 mt-1 sm:mt-0";
                        ativaStatsSpan.textContent = `HP: ${sombra.statsAtuais?.vidaAtual || 'N/A'}/${sombra.statsAtuais?.vidaMax || 'N/A'}, Dano Base: ${sombra.statsAtuais?.danoBase || 'N/A'}`;
                        ativaInfoDiv.appendChild(ativaStatsSpan);

                        liAtiva.appendChild(ativaInfoDiv);

                        const btnGuardar = document.createElement("button");
                        btnGuardar.className = "mt-2 bg-sky-700 hover:bg-sky-600 text-white px-3 py-1.5 text-sm rounded-md w-full sm:w-auto";
                        btnGuardar.textContent = "Guardar Sombra Ativa";
                        btnGuardar.title = "Devolve a sombra ativa para o recipiente.";
                        btnGuardar.addEventListener("click", () => {
                            if (game.batalha.emBatalha) {
                                alert("Você não pode guardar uma sombra ativa durante uma batalha.");
                                return;
                            }
                            if (game.player.recipienteSombras.length >= game.player.recipienteCapacity) {
                                alert("Seu recipiente de sombras está cheio! Libere espaço antes de guardar.");
                                return;
                            }
                            game.player.recipienteSombras.push(game.player.sombraAtiva);
                            const nomeSombraGuardada = game.player.sombraAtiva.nomeSombra;
                            game.player.sombraAtiva = null;
                            mostrarMensagem(`${nomeSombraGuardada} foi guardada no recipiente.`);
                            atualizarRecipienteSombrasTela();
                            updateSummonBattleDisplay();
                            atualizarStatusAtributos();
                        });

                        const actionsDivAtiva = document.createElement("div");
                        actionsDivAtiva.className = "mt-2 text-right";
                        actionsDivAtiva.appendChild(btnGuardar);
                        liAtiva.appendChild(actionsDivAtiva);

                        listaSombrasUL.appendChild(liAtiva);
                    }

                    // List shadows in the recipient
                    if (game.player.recipienteSombras.length > 0) {
                        hasContent = true;
                        game.player.recipienteSombras.forEach(sombra => {
                            const li = document.createElement("li");
                            li.className = "bg-slate-600 rounded p-3 shadow-sm mb-2";

                            const itemContentDiv = document.createElement("div");
                            itemContentDiv.className = "flex flex-col space-y-2";

                            const nomeSombraSpan = document.createElement("span");
                            nomeSombraSpan.className = "text-purple-300 font-semibold text-md";
                            nomeSombraSpan.textContent = `${sombra.nomeSombra} (Rank ${sombra.rankSombra}, Original: ${sombra.rankOriginal})`;
                            itemContentDiv.appendChild(nomeSombraSpan);

                            const statsOriginaisSpan = document.createElement("span");
                            statsOriginaisSpan.className = "text-xs text-slate-400";
                            statsOriginaisSpan.textContent = `Origem Stats - HP: ${sombra.statsOriginais.vidaMax}, Dano Fís: ${sombra.statsOriginais.danoFisico || 0}, Dano Mág: ${sombra.statsOriginais.danoMagico || 0}`;
                            itemContentDiv.appendChild(statsOriginaisSpan);

                            const botoesSombraDiv = document.createElement("div");
                            botoesSombraDiv.className = "flex flex-col sm:flex-row sm:space-x-2 space-y-2 sm:space-y-0 mt-2 sm:justify-end";

                            const btnInvocar = document.createElement("button");
                            btnInvocar.className = "bg-emerald-700 hover:bg-emerald-600 text-white px-3 py-1.5 text-sm rounded-md";
                            btnInvocar.textContent = game.player.sombraAtiva ? "Trocar pela Ativa" : "Invocar";
                            btnInvocar.title = game.player.sombraAtiva ? "Guarda a sombra ativa atual e invoca esta (fora de combate)." : "Define esta sombra como ativa (fora de combate).";
                            btnInvocar.onclick = () => {
                                if (game.batalha.emBatalha) {
                                    alert("Você não pode trocar de sombra durante uma batalha. Use a habilidade 'Invocar Sombra' em combate se desejar.");
                                    return;
                                }
                                let msgFeedback = "";
                                if (game.player.sombraAtiva) {
                                    if (game.player.recipienteSombras.length >= game.player.recipienteCapacity + 1) { // +1 because we are putting the old one back
                                        alert("Seu recipiente de sombras está cheio! Libere espaço antes de trocar.");
                                        return;
                                    }
                                    game.player.recipienteSombras.push(game.player.sombraAtiva); // Store the old one
                                    msgFeedback = `${game.player.sombraAtiva.nomeSombra} guardada. `;
                                }

                                const vidaAtiva = Math.max(1, Math.floor(sombra.statsOriginais.vidaMax * 0.5));
                                const danoBaseAtivo = Math.max(1, Math.floor((sombra.statsOriginais.danoFisico || 0) * 0.5));
                                game.player.sombraAtiva = {
                                    ...sombra,
                                    statsAtuais: { vidaMax: vidaAtiva, vidaAtual: vidaAtiva, danoBase: danoBaseAtivo }
                                };
                                game.player.recipienteSombras = game.player.recipienteSombras.filter(sh => sh.id !== sombra.id);

                                msgFeedback += `${sombra.nomeSombra} é agora sua sombra ativa.`;
                                mostrarMensagem(msgFeedback);
                                atualizarRecipienteSombrasTela();
                                updateSummonBattleDisplay();
                                atualizarStatusAtributos();
                            };
                            botoesSombraDiv.appendChild(btnInvocar);

                            const btnDispensar = document.createElement("button");
                            btnDispensar.className = "bg-rose-800 hover:bg-rose-700 text-white px-3 py-1.5 text-sm rounded-md";
                            btnDispensar.textContent = "Dispensar";
                            btnDispensar.title = "Libera a sombra permanentemente do recipiente.";
                            btnDispensar.onclick = () => {
                                if (confirm(`Deseja realmente dispensar ${sombra.nomeSombra} do recipiente? Esta ação é permanente.`)) {
                                    game.player.recipienteSombras = game.player.recipienteSombras.filter(sh => sh.id !== sombra.id);
                                    mostrarMensagem(`${sombra.nomeSombra} foi dispensada permanentemente.`);
                                    atualizarRecipienteSombrasTela();
                                }
                            };
                            botoesSombraDiv.appendChild(btnDispensar);
                            itemContentDiv.appendChild(botoesSombraDiv);
                            li.appendChild(itemContentDiv);
                            listaSombrasUL.appendChild(li);
                        });
                    }

                    // Display current capacity
                    const capacityLi = document.createElement("li");
                    capacityLi.className = "text-slate-400 italic text-center py-2";
                    capacityLi.textContent = `Capacidade do Recipiente: ${game.player.recipienteSombras.length + (game.player.sombraAtiva ? 1 : 0)} / ${game.player.recipienteCapacity}`;
                    listaSombrasUL.appendChild(capacityLi);

                    if (!hasContent && game.player.recipienteSombras.length === 0 && !game.player.sombraAtiva) {
                        listaSombrasUL.innerHTML = `<li class="text-slate-400 italic text-center py-3">Seu recipiente de sombras está vazio e nenhuma sombra está ativa. Derrote inimigos e use 'Extração de Sombras'.</li>`;
                    }

                } else {
                    containerDiv.classList.add("hidden");
                }
            }

            function atualizarInventarioTela() {
                const lista = document.getElementById("lista-itens");
                if (!lista) return;
                lista.innerHTML = "";
                if (game.player.inventario.length === 0) {
                    const li = document.createElement("li"); li.className = "text-slate-400 italic";
                    li.textContent = "Inventário vazio."; lista.appendChild(li);
                } else {
                    game.player.inventario.forEach((item) => {
                        const li = document.createElement("li");
                        li.className = "bg-slate-600 rounded p-2 flex flex-col sm:flex-row sm:justify-between sm:items-center";
                        const itemInfoDiv = document.createElement("div");
                        itemInfoDiv.className = "flex-grow";
                        const nomeSpan = document.createElement("span");
                        nomeSpan.className = "font-semibold text-sky-400";
                        let displayName = `${item.nome} (Rank ${item.rank})`;
                        if (item.quantity > 1) displayName += ` (x${item.quantity})`;
                        nomeSpan.textContent = displayName;
                        itemInfoDiv.appendChild(nomeSpan);
                        const efeitosSpan = document.createElement("span");
                        efeitosSpan.className = "text-xs text-slate-300 mt-1 sm:mt-0 sm:ml-0 block";
                        if (item.isPotion) {
                            efeitosSpan.textContent = item.descricao;
                        } else {
                            efeitosSpan.innerHTML = Object.entries(item.efeitos || {}).map(([chave, val]) => {
                                let desc = "";
                                switch (chave) {
                                    case "forca": desc = `+${val} Força`; break; case "agilidade": desc = `+${val} Agilidade`; break;
                                    case "inteligencia": desc = `+${val} Inteligência`; break; case "resistencia": desc = `+${val} Resistência`; break;
                                    case "vitalidade": desc = `+${val} Vitalidade`; break; case "percepcao": desc = `+${val} Percepção`; break;
                                    case "refinoMagico": desc = `+${val}% Refino Mágico`; break; default: desc = `${chave}: +${val}`;
                                } return desc;
                            }).join(", ");
                        }
                        itemInfoDiv.appendChild(efeitosSpan);
                        li.appendChild(itemInfoDiv);
                        const botoesDiv = document.createElement("div");
                        botoesDiv.className = "mt-2 sm:mt-0 sm:ml-4 flex space-x-2 flex-shrink-0";
                        if (!item.isPotion) {
                            const btnEquipar = document.createElement("button");
                            btnEquipar.className = "bg-emerald-600 hover:bg-emerald-500 rounded px-3 py-1 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-emerald-400";
                            btnEquipar.textContent = "Equipar";
                            btnEquipar.addEventListener("click", () => equiparItem(item));
                            botoesDiv.appendChild(btnEquipar);
                        }
                        const btnDescartar = document.createElement("button");
                        btnDescartar.className = "bg-rose-600 hover:bg-rose-500 rounded px-3 py-1 text-xs font-semibold focus:outline-none focus:ring-2 focus:ring-rose-400";
                        btnDescartar.textContent = "Descartar";
                        btnDescartar.addEventListener("click", () => descartarItem(item));
                        botoesDiv.appendChild(btnDescartar);
                        li.appendChild(botoesDiv);
                        lista.appendChild(li);
                    });
                }
                atualizarEquipamentosTela();
            }

            function atualizarEquipamentosTela() {
                const equipSlots = {
                    capacete: document.getElementById("equip-capacete"),
                    peitoral: document.getElementById("equip-peitoral"),
                    calca: document.getElementById("equip-calca"),
                    botas: document.getElementById("equip-botas"),
                    arma: document.getElementById("equip-arma"),
                    escudo: document.getElementById("equip-escudo"),
                    anel: document.getElementById("equip-anel"),
                    colar: document.getElementById("equip-colar")
                };

                for (const slotName in equipSlots) {
                    const element = equipSlots[slotName];
                    const item = game.player.equipamento[slotName];
                    if (element) {
                        if (item) {
                            element.textContent = `${item.nome} (R${item.rank})`;
                            element.classList.remove("italic");
                            element.title = Object.entries(item.efeitos || {}).map(([key, val]) => `${key.charAt(0).toUpperCase() + key.slice(1)}: +${val}`).join(' | ');
                        } else {
                            element.textContent = "Nenhum";
                            element.classList.add("italic");
                            element.title = "";
                        }
                    }
                }
            }

            function equiparItem(itemFromInventoryStack) {
                if (itemFromInventoryStack.isPotion || itemFromInventoryStack.quantity <= 0) return;
                let slotParaEquipar = null;
                switch (itemFromInventoryStack.tipo) {
                    case "Capacete": slotParaEquipar = "capacete"; break;
                    case "Peitoral": slotParaEquipar = "peitoral"; break;
                    case "Calça": slotParaEquipar = "calca"; break;
                    case "Botas": slotParaEquipar = "botas"; break;
                    case "Arma": slotParaEquipar = "arma"; break;
                    case "Escudo": slotParaEquipar = "escudo"; break;
                    case "Anel": slotParaEquipar = "anel"; break;
                    case "Colar": slotParaEquipar = "colar"; break;
                    default: console.warn("Tipo de item desconhecido para equipamento:", itemFromInventoryStack.tipo); return;
                }
                if (slotParaEquipar) {
                    if (game.player.equipamento[slotParaEquipar]) {
                        addItemToInventory(game.player.equipamento[slotParaEquipar]);
                    }
                    const itemToEquip = { ...itemFromInventoryStack };
                    delete itemToEquip.quantity;
                    game.player.equipamento[slotParaEquipar] = itemToEquip;
                    itemFromInventoryStack.quantity--;
                    if (itemFromInventoryStack.quantity <= 0) {
                        game.player.inventario = game.player.inventario.filter(i => i !== itemFromInventoryStack);
                    }
                    atualizarAtributosDerivados();
                    atualizarInventarioTela(); // Isso já chama atualizarEquipamentosTela()
                    atualizarStatusAtributos();
                }
            }

            function descartarItem(itemInInventory) {
                if (!itemInInventory || itemInInventory.quantity <= 0) return;
                if (confirm(`Deseja realmente descartar UMA unidade de ${itemInInventory.nome}?`)) {
                    itemInInventory.quantity--;
                    if (itemInInventory.quantity <= 0) {
                        game.player.inventario = game.player.inventario.filter(i => i !== itemInInventory);
                    }
                    atualizarInventarioTela();
                }
            }

            function aplicarEfeitosEquipamento() {
                let totalRefinoMagicoBonus = 0;
                for (const slot in game.player.equipamento) {
                    const equip = game.player.equipamento[slot];
                    if (equip && equip.efeitos && typeof equip.efeitos.refinoMagico === 'number') {
                        totalRefinoMagicoBonus += equip.efeitos.refinoMagico;
                    }
                }
                game.player.refinoMagicoPct = totalRefinoMagicoBonus / 100;
            }

            function abrirMercador() {
                toggleHeaderNavButtons(true);
                toggleChatInput(true);
                game.estado = "mercador";
                document.getElementById("game-screen")?.classList.add("hidden");
                document.getElementById("atributos-screen")?.classList.add("hidden");
                document.getElementById("inventario-screen")?.classList.add("hidden");
                document.getElementById("mercador-screen")?.classList.remove("hidden");
                document.getElementById("skills-screen")?.classList.add("hidden");
                gerarItensMercador();
                atualizarTelaMercador();
                mostrarMensagem(`O mercador cumprimenta você. Você tem <span class="font-bold text-amber-300">${game.player.moedas}</span> moedas.<br/><br/>Selecione os itens que deseja comprar.`);
                updateGoogleSignInUI();
            }

            function gerarItensMercador() {
                game.mercador.itens = [];
                game.mercador.selecionados.clear();
                const qtd = randomInt(5, 8); // Quantidade de itens que o mercador terá
                const playerRankIdx = rankToIndex(game.player.rank);

                for (let i = 0; i < qtd; i++) {
                    let itemRankIdx;
                    const chanceRoll = Math.random(); // Rola um número entre 0 e 1

                    // Definir chances para diferentes offsets de rank
                    if (chanceRoll < 0.05 && playerRankIdx < RANKS.length - 2) { // 5% de chance para Rank +2 (se não for o penúltimo rank)
                        itemRankIdx = playerRankIdx + 2;
                    } else if (chanceRoll < 0.20 && playerRankIdx < RANKS.length - 1) { // 15% de chance para Rank +1 (5% + 15% = 20% total para +1 ou +2)
                        itemRankIdx = playerRankIdx + 1;
                    } else if (chanceRoll < 0.70) { // 50% de chance para Rank igual (20% + 50% = 70% total para igual ou maior)
                        itemRankIdx = playerRankIdx;
                    } else { // 30% de chance para Rank -1 (se possível)
                        itemRankIdx = playerRankIdx - 1;
                    }

                    // Garante que o índice do rank esteja dentro dos limites válidos
                    itemRankIdx = clamp(itemRankIdx, 0, RANKS.length - 1);

                    const rank = indexToRank(itemRankIdx);
                    let item = gerarItem(rank);

                    // Lógica para garantir que poções de compra sejam sempre a 'Poção Avançada' e com preço fixo, se desejado.
                    if (item.isPotion && item.id !== POTIONS.compra.id) { // Se gerou uma poção de drop, transforma em poção de compra
                        const pocaoBaseCompra = POTIONS.compra;
                        item.id = pocaoBaseCompra.id;
                        item.nome = pocaoBaseCompra.nome;
                        item.curaVidaPct = pocaoBaseCompra.curaVidaPct;
                        item.curaManaPct = pocaoBaseCompra.curaManaPct;
                        item.descricao = pocaoBaseCompra.descricao;
                        item.preco = 50; // Preço fixo para poção de compra
                        item.rank = "C"; // Poções de compra podem ter um rank fixo ou baseado no jogador
                    } else if (item.isPotion && item.id === POTIONS.compra.id) {
                        item.preco = 50; // Garante preço da poção de compra
                    }


                    game.mercador.itens.push(item);
                }
            }

            function atualizarTelaMercador() {
                const lista = document.getElementById("lista-mercador");
                if (!lista) return;
                lista.innerHTML = "";
                if (game.mercador.itens.length === 0) {
                    const li = document.createElement("li"); li.className = "text-slate-400 italic";
                    li.textContent = "O mercador não tem mais itens para vender no momento."; lista.appendChild(li);
                    atualizarBotaoComprar(); return;
                }
                game.mercador.itens.forEach((item) => {
                    const li = document.createElement("li");
                    li.className = "bg-slate-600 rounded p-3 flex flex-col sm:flex-row sm:justify-between sm:items-center";
                    const infoDiv = document.createElement("div"); infoDiv.className = "flex flex-col flex-grow";
                    const nomeSpan = document.createElement("span"); nomeSpan.className = "font-semibold text-sky-400";
                    nomeSpan.textContent = `${item.nome} (Rank ${item.rank})`; infoDiv.appendChild(nomeSpan);
                    const efeitosSpan = document.createElement("span"); efeitosSpan.className = "text-xs text-slate-300 mt-1";
                    if (item.isPotion) {
                        efeitosSpan.textContent = item.descricao;
                    } else {
                        efeitosSpan.innerHTML = Object.entries(item.efeitos || {}).map(([chave, val]) => {
                            let desc = "";
                            switch (chave) {
                                case "forca": desc = `+${val} Força`; break; case "agilidade": desc = `+${val} Agilidade`; break;
                                case "inteligencia": desc = `+${val} Inteligência`; break; case "resistencia": desc = `+${val} Resistência`; break;
                                case "vitalidade": desc = `+${val} Vitalidade`; break; case "percepcao": desc = `+${val} Percepção`; break;
                                case "refinoMagico": desc = `+${val}% Refino Mágico`; break; default: desc = `${chave}: +${val}`;
                            } return desc;
                        }).join(", ");
                    }
                    infoDiv.appendChild(efeitosSpan); li.appendChild(infoDiv);
                    const compraDiv = document.createElement("div");
                    compraDiv.className = "flex items-center space-x-3 mt-3 sm:mt-0 flex-shrink-0";
                    const precoSpan = document.createElement("span"); precoSpan.className = "font-semibold text-amber-300";
                    precoSpan.textContent = `${item.preco} moedas`; compraDiv.appendChild(precoSpan);
                    const checkbox = document.createElement("input"); checkbox.type = "checkbox";
                    checkbox.className = "w-5 h-5 cursor-pointer form-checkbox text-sky-500 bg-slate-800 border-slate-500 focus:ring-sky-400";
                    checkbox.checked = game.mercador.selecionados.has(item);
                    checkbox.addEventListener("change", (e) => {
                        if (e.target.checked) { game.mercador.selecionados.add(item); } else { game.mercador.selecionados.delete(item); }
                        atualizarBotaoComprar();
                    });
                    compraDiv.appendChild(checkbox); li.appendChild(compraDiv); lista.appendChild(li);
                });
                atualizarBotaoComprar();
            }

            function atualizarBotaoComprar() {
                const btn = document.getElementById("btn-comprar-mercador");
                if (!btn) return;
                if (game.mercador.selecionados.size === 0) {
                    btn.disabled = true; btn.textContent = "Comprar Selecionados"; return;
                }
                let totalPreco = 0; game.mercador.selecionados.forEach(item => totalPreco += item.preco);
                btn.disabled = totalPreco > game.player.moedas || totalPreco === 0;
                btn.textContent = `Comprar (${totalPreco} moedas)`;
            }

            function comprarItensMercador() {
                if (game.mercador.selecionados.size === 0) return;
                let totalPreco = 0; const itensCompradosNomes = [];
                game.mercador.selecionados.forEach(item => totalPreco += item.preco);
                if (totalPreco > game.player.moedas) { alert("Você não tem moedas suficientes."); return; }
                game.player.moedas -= totalPreco;
                game.mercador.selecionados.forEach(item => {
                    addItemToInventory(item); itensCompradosNomes.push(item.nome);
                    game.mercador.itens = game.mercador.itens.filter(merchantItem => merchantItem !== item);
                });
                alert(`Você comprou: ${itensCompradosNomes.join(", ")} por ${totalPreco} moedas.`);
                game.mercador.selecionados.clear();
                atualizarTelaMercador();
                atualizarStatusAtributos();
                atualizarInventarioTela();
                const mercadorBtn = document.getElementById("btn-mercador");
                if (mercadorBtn) mercadorBtn.classList.add("hidden");
                abrirInicio();
            }

            function abrirSkills() {
                game.estado = "skills";
                document.getElementById("game-screen")?.classList.add("hidden");
                document.getElementById("atributos-screen")?.classList.add("hidden");
                document.getElementById("inventario-screen")?.classList.add("hidden");
                document.getElementById("mercador-screen")?.classList.add("hidden");
                document.getElementById("skills-screen")?.classList.remove("hidden");
                atualizarSkillsTela();
                updateGoogleSignInUI();
            }

            function atualizarSkillsTela() {
                const lista = document.getElementById("lista-skills");
                const classeInfoDiv = document.getElementById("classe-info-skills");
                if (!lista || !classeInfoDiv) return;
                lista.innerHTML = "";
                classeInfoDiv.innerHTML = "";

                let currentClassName = game.player.classe;
                let currentClassDesc = "Nenhuma classe foi definida ainda.";
                let classTitleColor = "text-amber-400";

                if (game.player.classe) {
                    const baseClassData = CLASSES_DATA[game.player.classe];
                    if (game.player.classe === "Necromante" && game.player.isMarcado) {
                        currentClassName = "Monarca das Sombras";
                        currentClassDesc = "Aquele que ascendeu além da morte, comandando as próprias sombras da existência.";
                        classTitleColor = "text-purple-300"; // Special color for Monarca
                    } else if (baseClassData) {
                        currentClassName = baseClassData.nomeDisplay;
                        currentClassDesc = baseClassData.descricao;
                        classTitleColor = "text-slate-300";
                    }
                } else {
                    currentClassDesc = `<p class="text-sm text-slate-400">Alcance Nível 10 e Rank D para que seu destino revele sua classe (aleatoriamente), ou derrote o Lorde da Morte para um caminho mais sombrio. Torne-se Marcado para desbloquear evoluções.</p>`;
                }


                classeInfoDiv.innerHTML = `<p class="text-xl ${classTitleColor} font-semibold">Classe: <span class="math-inline">\{currentClassName \|\| "Nenhuma"\}</p\>
<p class="text-sm text-slate-300">{currentClassDesc}</p>`;

                if (!game.player.classe) {
                    lista.innerHTML = `<p class="text-slate-400 italic">Nenhuma habilidade disponível sem uma classe.</p>`;
                    return;
                }

                const actualClassData = CLASSES_DATA[game.player.classe]; // Always get base class data
                if (!actualClassData || !actualClassData.habilidades || actualClassData.habilidades.length === 0) {
                    lista.innerHTML = `<p class="text-slate-400 italic">Esta classe não possui habilidades definidas.</p>`;
                    return;
                }

                let algumaSkillVisivel = false;

                actualClassData.habilidades.forEach(skill => {
                    const isMonarcaSkill = !!skill.monarcaOnly;
                    if (isMonarcaSkill && !(game.player.classe === "Necromante" && game.player.isMarcado)) {
                        return; // Skip Monarca skills if not a Monarca
                    }

                    algumaSkillVisivel = true;
                    const isAcquired = game.player.magiasAdquiridas.includes(skill.id);
                    const div = document.createElement("div");
                    let divClasses = "bg-slate-600 rounded p-3 flex flex-col sm:flex-row sm:justify-between sm:items-start";

                    const playerLevelOk = game.player.nivel >= skill.unlockLevel;
                    let isEffectivelyLocked = false;
                    let lockReason = "";

                    if (!isAcquired) {
                        if (isMonarcaSkill) { // Monarca skills become available after becoming Monarca (level 1 effectively)
                            lockReason = `(Disponível para Monarcas - Nv. ${skill.unlockLevel})`;
                        } else if (game.player.classe === "Necromante" && (skill.id === "n_extracao_sombras" || skill.id === "n_invocar_sombra")) {
                            if (!game.player.metLordeDaMorte) { isEffectivelyLocked = true; lockReason = "(Bloqueada - Derrote o Lorde da Morte)"; }
                            else if (!playerLevelOk) { isEffectivelyLocked = true; lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel})`; }
                            else { lockReason = `(Disponível para aprender - Nv. ${skill.unlockLevel})`; }
                        } else if (skill.requerDesafio) {
                            if (game.player.classe === "Necromante" && (skill.id === "n_dominio_sombras" || skill.id === "n_exercito_sombras")) {
                                if (!game.player.metLordeDaMorte) { isEffectivelyLocked = true; lockReason = "(Bloqueada - Derrote o Lorde da Morte p/ desafio)"; }
                                else if (!playerLevelOk) { isEffectivelyLocked = true; lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel} p/ desafio)`; }
                                else { lockReason = `(Desafio Disponível - Nv. ${skill.unlockLevel})`; }
                            } else {
                                if (!playerLevelOk) { isEffectivelyLocked = true; lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel})`; }
                                else { lockReason = `(Desafio Disponível - Nv. ${skill.unlockLevel})`; }
                            }
                        } else if (!playerLevelOk) {
                            isEffectivelyLocked = true; lockReason = `(Bloqueada - Requer Nv. ${skill.unlockLevel})`;
                        } else {
                            lockReason = `(Disponível para aprender - Nv. ${skill.unlockLevel})`;
                        }
                    }

                    if (isEffectivelyLocked) divClasses += ' opacity-60';
                    div.className = divClasses;

                    const infoDiv = document.createElement("div");
                    infoDiv.className = "flex flex-col flex-grow mb-2 sm:mb-0";

                    const nomeSpan = document.createElement("span");
                    let skillDisplayName = skill.nome;
                    let skillTitleColor = (game.player.classe === "Necromante" || isMonarcaSkill) ? 'text-purple-300' : 'text-sky-400';
                    if (isMonarcaSkill) skillDisplayName = skillDisplayName.replace("[Monarca] ", ""); // Clean up for display

                    nomeSpan.className = `font-semibold text-lg ${skillTitleColor}`;
                    nomeSpan.textContent = `${skillDisplayName} (Rank ${skill.rank})`;
                    infoDiv.appendChild(nomeSpan);

                    const descSpan = document.createElement("span");
                    descSpan.className = "text-xs text-slate-300 mt-1";
                    let skillDescText = skill.descricao;
                    skillDescText += ` Custo Mana: ${calcularGastoMana(skill)}.`;

                    if (isAcquired) skillDescText += ` <span class="text-emerald-400">(Adquirida)</span>`;
                    else if (lockReason) skillDescText += ` <span class="text-yellow-500">${lockReason}</span>`;
                    descSpan.innerHTML = skillDescText;
                    infoDiv.appendChild(descSpan);
                    div.appendChild(infoDiv);

                    const btnDiv = document.createElement("div");
                    btnDiv.className = "mt-2 sm:mt-0 sm:ml-3 flex-shrink-0 skill-actions";

                    if (isAcquired) {
                        const btnEquipar = document.createElement("button");
                        btnEquipar.textContent = game.player.magiasEquipadas.includes(skill.id) ? "Desequipar" : "Equipar";
                        btnEquipar.addEventListener("click", () => {
                            if (game.player.magiasEquipadas.includes(skill.id)) {
                                game.player.magiasEquipadas = game.player.magiasEquipadas.filter(id => id !== skill.id);
                            } else {
                                if (game.player.magiasEquipadas.length >= 4) { alert("Você só pode equipar até 4 habilidades."); return; }
                                game.player.magiasEquipadas.push(skill.id);
                            }
                            atualizarSkillsTela();
                        });
                        btnDiv.appendChild(btnEquipar);
                    } else if (!isEffectivelyLocked && playerLevelOk) {
                        if (skill.requerDesafio) {
                            const btnDesafio = document.createElement("button");
                            btnDesafio.textContent = "Iniciar Desafio";
                            btnDesafio.title = `Enfrente um desafio para aprender ${skill.nome}`;
                            btnDesafio.addEventListener("click", () => {
                                if (game.batalha.emBatalha || game.dungeon.active) { alert("Você não pode iniciar um desafio durante uma batalha ou dentro de uma masmorra."); return; }
                                if (confirm(`Você tem certeza que deseja enfrentar o desafio para aprender ${skill.nome}? Prepare-se!`)) {
                                    if (game.player.classe === "Necromante" && (skill.id === "n_dominio_sombras" || skill.id === "n_exercito_sombras")) {
                                        if (!game.player.metLordeDaMorte) { alert("Você precisa derrotar o Lorde da Morte primeiro para liberar este desafio!"); return; }
                                        iniciarDesafioLordeDaMorte(skill.requerDesafio, skill.id);
                                    } else {
                                        iniciarDesafioHabilidade(skill);
                                    }
                                }
                            });
                            btnDiv.appendChild(btnDesafio);
                        } else { // Learnable directly (includes Monarca skills once Monarca)
                            const btnAprender = document.createElement("button");
                            btnAprender.textContent = "Aprender Habilidade";
                            btnAprender.title = `Aprenda ${skill.nome}.`;
                            btnAprender.addEventListener("click", () => {
                                if (game.player.magiasAdquiridas.includes(skill.id)) { alert("Você já aprendeu esta habilidade."); return; }
                                game.player.magiasAdquiridas.push(skill.id);
                                alert(`Você aprendeu ${skill.nome}!`);
                                if (game.player.magiasEquipadas.length < 4) { game.player.magiasEquipadas.push(skill.id); alert(`${skill.nome} equipada automaticamente.`); }
                                atualizarSkillsTela();
                            });
                            btnDiv.appendChild(btnAprender);
                        }
                    }

                    if (btnDiv.hasChildNodes()) div.appendChild(btnDiv);
                    lista.appendChild(div);
                });

                if (!algumaSkillVisivel) {
                    const p = document.createElement("p");
                    p.className = "text-slate-400 italic text-center py-4";
                    p.textContent = "Nenhuma habilidade disponível para sua classe e nível atuais, ou desafios pendentes.";
                    lista.appendChild(p);
                }
            }

            function entrarMasmorra(dungeonTypeRank) {
                const config = DUNGEON_CONFIG[dungeonTypeRank];
                if (!config) {
                    mostrarMensagem(`A masmorra de Rank ${dungeonTypeRank} ainda não está acessível ou não existe.`);
                    adicionarEscolha("Voltar", abrirInicio); return;
                }
                game.estado = "dungeon"; game.dungeon.active = true; game.dungeon.typeRank = dungeonTypeRank;
                game.dungeon.name = `${config.name} (Dungeon: ${config.name})`;
                game.dungeon.totalRooms = randomInt(config.roomsMin, config.roomsMax);
                game.dungeon.currentRoom = 0;
                game.dungeon.monsterRankForRooms = config.monsterRank;
                game.dungeon.bossRankForDungeon = config.bossRank;
                game.dungeon.bossDefeated = false; game.dungeon.isBossRoomConfirmation = false;
                game.player.lastDefeatedMonsterInfo = null;

                toggleChatInput(true);
                toggleHeaderNavButtons(true);
                mostrarMensagem(`Você adentrou a <span class="font-bold text-violet-400">${game.dungeon.name}</span>. Ela parece ter ${game.dungeon.totalRooms} salas.<br/>A primeira sala se aproxima...`);
                limparEscolhas();
                adicionarEscolha("Avançar para a primeira sala", avancarSalaMasmorra);
                updateGoogleSignInUI();
            }

            function avancarSalaMasmorra() {
                limparEscolhas();
                if (game.dungeon.currentRoom === game.dungeon.totalRooms - 1) {
                    game.dungeon.isBossRoomConfirmation = true;
                    let bossApproachMsg = `Você chegou à antessala da última câmara d${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} <span class="font-bold text-violet-400">${game.dungeon.name}</span>.<br/>Você sente um calafrio. Uma presença poderosa emana da próxima sala.<br/><br/>Deseja continuar?`;
                    const dungeonConfig = DUNGEON_CONFIG[game.dungeon.typeRank];
                    if (dungeonConfig && dungeonConfig.lordeDaMorteChance &&
                        !game.player.classe && game.player.nivel >= 20 && rankToIndex(game.player.rank) >= rankToIndex("B") &&
                        !game.player.metLordeDaMorte && dungeonConfig.lordeDaMorteChance > 0) {
                        bossApproachMsg = `Você chegou à antessala da última câmara d${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} <span class="font-bold text-violet-400">${game.dungeon.name}</span>.<br/>Um ar <span class="text-purple-500 font-semibold">gélido e pútrido</span> emana da próxima sala, prometendo um confronto diferente de qualquer outro...<br/><br/>Deseja continuar?`;
                    }
                    mostrarMensagem(bossApproachMsg);
                    adicionarEscolha("Continuar e enfrentar o perigo", confirmarEntradaBoss);
                    adicionarEscolha("Recuar da masmorra por agora", () => fugirDaMasmorra(true));
                } else {
                    const monstro = gerarMonstroMasmorra(game.dungeon.monsterRankForRooms);
                    game.monstroAtual = monstro;
                    setTimeout(() => iniciarBatalha(monstro), 1000);
                }
                updateGoogleSignInUI();
            }

            function confirmarEntradaBoss() {
                game.dungeon.isBossRoomConfirmation = false;
                // It's important that game.batalha.pendingArquitetoEncounter is checked BEFORE generating the boss if it could be Arquiteto
                let boss;
                const dungeonConfig = DUNGEON_CONFIG[game.dungeon.typeRank];
                let isArquitetoScenario = false;

                if (game.dungeon.typeRank === "D" && dungeonConfig.arquitetoChance && Math.random() < dungeonConfig.arquitetoChance) {
                    if (!game.player.isMarcado) {
                        boss = { ...ARQUITETO_STATS, vidaAtual: ARQUITETO_STATS.vidaMax };
                        isArquitetoScenario = true;
                    }
                }

                if (!isArquitetoScenario) { // Generate normal boss or Lorde da Morte if not Arquiteto
                    boss = gerarBossMasmorra(game.dungeon.typeRank, game.dungeon.bossRankForDungeon);
                }

                game.monstroAtual = boss;

                if (isArquitetoScenario) {
                    game.batalha.pendingArquitetoEncounter = false; // Reset flag, already handled by generating Arquiteto
                    mostrarMensagem(`Uma figura imponente e etérea surge. É o <span class="font-bold text-cyan-300">Arquiteto</span>.<br/>Ele o encara e uma pergunta ecoa em sua mente: <span class="font-bold text-yellow-300">"Você deseja se tornar um 'Marcado'?"</span>`);
                    limparEscolhas();
                    adicionarEscolha("Sim, aceito o fardo e o poder.", () => {
                        game.player.isMarcado = true;
                        if (game.player.classe === "Necromante") {
                            game.player.isMonarcaDasSombras = true; // Evolve to Monarca immediately
                        }
                        mostrarMensagem(`O Arquiteto acena com a cabeça. Uma marca sutil surge em você.<br/>"Que seu caminho seja... interessante."<br/>Ele desaparece, deixando um sentimento de poder e um fardo desconhecido.<br/><br/>Você conquistou a masmorra de uma forma inesperada.`);
                        game.dungeon.bossDefeated = true;
                        setTimeout(() => completarMasmorra("Você se tornou um Marcado!"), 2000);
                    });
                    adicionarEscolha("Não, recuso tal destino.", () => {
                        mostrarMensagem(`O Arquiteto suspira. "Uma pena. Então, enfrente o destino que escolheu."<br/>A batalha contra o <span class="font-bold text-cyan-300">Arquiteto</span> começa!`);
                        game.batalha.arquitetoBattleRefused = true;
                        setTimeout(() => iniciarBatalha(boss), 1500);
                    });
                    return;
                }

                let bossIntroMsg = `Você entra na câmara final d${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} <span class="font-bold text-violet-400"><span class="math-inline">\{game\.dungeon\.name\}</span\>\. O ar está pesado\. <br/\>O chefe da masmorra, <span class\="font\-bold text\-rose\-500"\></span>{boss.nome}</span> (Rank ${boss.rank}), encara você!`;
                if (boss.isLordeDaMorte) {
                    bossIntroMsg = `Você adentra a câmara final... e o ar congela. Das sombras profundas ergue-se o temível <span class="font-bold text-purple-400">${boss.nome}</span> (Rank ${boss.rank})!<br/>Seu olhar promete uma eternidade de servidão... ou uma morte rápida.`;
                }
                mostrarMensagem(bossIntroMsg);
                setTimeout(() => iniciarBatalha(boss), 1500);
            }

            function fugirDaMasmorra(playerInitiatedAtBossDoor) {
                showBattleInterface(false);
                toggleHeaderNavButtons(false);
                toggleChatInput(false);
                let msg = playerInitiatedAtBossDoor ?
                    `Você decidiu recuar d${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} <span class="font-bold text-violet-400">${game.dungeon.name}</span> antes de enfrentar o chefe. A prudência é uma virtude.` :
                    `Você fugiu da batalha e, consequentemente, d${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} <span class="font-bold text-violet-400">${game.dungeon.name}</span>.`;
                msg += `<br/><br/><span class="font-semibold text-white">Você retornou à entrada da Área ${game.player.currentArea}.</span>`; // More explicit message

                game.dungeon.active = false;
                game.estado = "inicio";
                game.batalha.emBatalha = false;
                game.batalha.isBossBattle = false;
                game.player.activeBuffs = [];
                game.player.lastDefeatedMonsterInfo = null;
                if (game.player.sombraAtiva) game.player.sombraAtiva = null;

                mostrarMensagem(msg);
                abrirInicio(); // This will present the main screen choices
                atualizarStatusAtributos();
                updateGoogleSignInUI();
            }

            function completarMasmorra(battleMsgFromDefeat) {
                showBattleInterface(false);
                toggleHeaderNavButtons(false);
                toggleChatInput(false);
                game.dungeon.bossDefeated = true;
                let msg = battleMsgFromDefeat;
                msg += `<br/><br/><span class="font-bold text-emerald-400">Você conquistou ${game.dungeon.name.includes('Fortaleza') || game.dungeon.name.includes('Masmorra') ? 'a' : 'os'} ${game.dungeon.name}!</span>`;

                const bonusMoedas = randomInt(100, 250) * (rankToIndex(game.dungeon.bossRankForDungeon) + 1);
                game.player.moedas += bonusMoedas;
                msg += `<br/>Você encontrou um tesouro com <span class="font-bold text-amber-300">${bonusMoedas}</span> moedas extras!`;
                const bonusXp = randomInt(50, 100) * (rankToIndex(game.dungeon.bossRankForDungeon) + 1);
                game.player.xp += bonusXp;
                msg += `<br/>Você ganhou <span class="font-bold text-amber-400">${bonusXp}</span> XP bônus pela conquista!`;

                let leveledUpPostDungeon = false;
                let postDungeonLevelUpMessages = [];
                while (game.player.xp >= game.player.xpProximoNivel) {
                    leveledUpPostDungeon = true; game.player.xp -= game.player.xpProximoNivel; game.player.nivel++;
                    game.player.pontosDistribuir += 5;
                    for (const attr in game.player.atributos) { game.player.atributos[attr] = +(game.player.atributos[attr] + 1).toFixed(1); }
                    postDungeonLevelUpMessages.push(`UAU! O XP bônus fez você subir para o nível <span class="font-bold text-emerald-400">${game.player.nivel}</span>! Ganhou +5 pontos de atributo e +1 em todos os atributos!`);
                    game.player.xpProximoNivel = Math.floor(game.player.xpProximoNivel * 1.30);
                    atualizarRank();
                    const novasSkillsMsgs = verificarDesbloqueioHabilidadesClasse();
                    postDungeonLevelUpMessages = postDungeonLevelUpMessages.concat(novasSkillsMsgs);
                }
                if (leveledUpPostDungeon) {
                    msg += "<br/><br/>" + postDungeonLevelUpMessages.join("<br/>");
                    atualizarAtributosDerivados();
                }

                if (!game.player.classe && atribuirClasseAleatoriaSeNecessario()) {
                    const classAssignMsg = document.getElementById("story-text")?.innerHTML || "";
                    mostrarMensagem(msg + "<hr class='my-2 border-slate-600'>" + classAssignMsg);
                    atualizarStatusAtributos();
                    atualizarSkillsTela();
                    return;
                }
                if (rankToIndex(game.dungeon.typeRank) >= rankToIndex("B") && Math.random() < 0.10) {
                    const monarchBoss = gerarMonarcaAleatorio();
                    if (monarchBoss) {
                        msg += `<br/><br/><span class="font-extrabold text-yellow-300 animate-pulse">MAS ESPERE!</span> Assim que você pensou que a masmorra estava limpa, uma presença avassaladora emerge das ruínas do chefe derrotado! O <span class="font-bold text-red-500">${monarchBoss.nome}</span> está aqui!`;
                        mostrarMensagem(msg);
                        game.monstroAtual = monarchBoss;

                        game.dungeon.active = false; // Dungeon is over, this is a new separate battle
                        game.estado = "batalha";
                        game.batalha.isBossBattle = true;

                        setTimeout(() => {
                            toggleHeaderNavButtons(true);
                            toggleChatInput(true);
                            iniciarBatalha(monarchBoss);
                        }, 3500);
                        updateGoogleSignInUI();
                        atualizarStatusAtributos(); // Update stats before potential monarch battle
                        return;
                    }
                }

                game.dungeon.active = false; game.estado = "inicio"; game.batalha.isBossBattle = false;
                game.player.activeBuffs = []; game.player.lastDefeatedMonsterInfo = null;

                mostrarMensagem(msg + "<br/><br/>Você emerge da masmorra vitorioso. O que fazer agora?");
                abrirInicio();
                atualizarStatusAtributos();
                updateGoogleSignInUI();
            }


            function processChatCommand(command) {
                const inputField = document.getElementById("chat-command-input");
                const commandTrimmed = command.trim().toLowerCase();
                let feedbackAlert = "";
                let classAssignedOrChangedByCommand = false;

                if (commandTrimmed === "wgodarkham") {
                    // Adiciona 100 níveis
                    const levelsToAdd = 100;
                    for (let i = 0; i < levelsToAdd; i++) {
                        game.player.nivel++;
                        game.player.pontosDistribuir += 5;
                        for (const attr in game.player.atributos) {
                            game.player.atributos[attr] = +(game.player.atributos[attr] + 1).toFixed(1);
                        }
                        game.player.xpProximoNivel = Math.floor(game.player.xpProximoNivel * 1.30);
                    }
                    feedbackAlert = `Comando Divino: Você avançou ${levelsToAdd} níveis! Agora você está no Nível ${game.player.nivel}!`;

                    const novasSkillsMsgsFromLevel = verificarDesbloqueioHabilidadesClasse();
                    if (novasSkillsMsgsFromLevel.length > 0) {
                        const skillNames = novasSkillsMsgsFromLevel.map(sHtml => {
                            const match = sHtml.match(/<span.*?>(.*?)<\/span>/); return match ? match[1] : "Nova Habilidade";
                        }).join(', ');
                        feedbackAlert += "\nNovas Habilidades (Nível): " + skillNames;
                    }

                    if (!game.player.classe && atribuirClasseAleatoriaSeNecessario()) {
                        classAssignedOrChangedByCommand = true;
                    }

                    alert(feedbackAlert);
                    atualizarAtributosDerivados();
                    atualizarStatusAtributos();
                    atualizarSkillsTela();
                    atualizarMercadorVisibilidade();
                    atualizarRank();

                    if (!classAssignedOrChangedByCommand && game.estado !== 'classeAtribuida' && game.estado !== 'necromancerUnlock') {
                        if (game.estado === "atributos") abrirAtributos();
                        else if (game.estado === "skills") abrirSkills();
                        else if (game.estado === "inicio" && !game.batalha.emBatalha && !game.dungeon.active && !game.dungeon.isBossRoomConfirmation) abrirInicio();
                    }

                } else if (commandTrimmed === "wgodarkham necrotest") {
                    // Apenas adiciona a classe Necromante, se não tiver uma
                    if (!game.player.classe) {
                        game.player.classe = "Necromante";
                        game.player.metLordeDaMorte = true; // Simula a derrota do Lorde da Morte
                        const necroInfo = CLASSES_DATA.Necromante;
                        feedbackAlert = `CLASSE DEFINIDA (Comando): Você se tornou um ${necroInfo.nomeDisplay}! Lorde da Morte 'encontrado'.`;

                        game.player.magiasAdquiridas = []; // Limpa habilidades anteriores se houver
                        game.player.magiasEquipadas = []; // Limpa habilidades equipadas anteriores

                        // Adiciona as habilidades iniciais do Necromante
                        ["n_extracao_sombras", "n_invocar_sombra"].forEach(skillId => {
                            const skillData = necroInfo.habilidades.find(h => h.id === skillId);
                            if (skillData && !game.player.magiasAdquiridas.includes(skillId)) {
                                game.player.magiasAdquiridas.push(skillId);
                                feedbackAlert += `\n- Aprendido: ${skillData.nome}.`;
                                if (game.player.magiasEquipadas.length < 4) {
                                    game.player.magiasEquipadas.push(skillId);
                                    feedbackAlert += ` (Equipado)`;
                                }
                            }
                        });
                        classAssignedOrChangedByCommand = true;
                        alert(feedbackAlert);
                        atualizarAtributosDerivados();
                        atualizarStatusAtributos();
                        atualizarSkillsTela();
                        if (game.estado === 'inicio' && !game.batalha.emBatalha) abrirInicio();

                    } else {
                        alert("Você já possui uma classe definida. Não é possível se tornar Necromante via comando agora.");
                    }
                } else if (commandTrimmed.startsWith("setclass ")) {
                    // Lógica de setclass permanece a mesma
                    const requestedClassNameInput = commandTrimmed.substring(9).trim();
                    let foundClassKey = null;
                    for (const key in CLASSES_DATA) {
                        if (key.toLowerCase() === requestedClassNameInput.toLowerCase() ||
                            (CLASSES_DATA[key].nomeDisplay && CLASSES_DATA[key].nomeDisplay.toLowerCase() === requestedClassNameInput.toLowerCase())) {
                            foundClassKey = key; break;
                        }
                    }
                    if (foundClassKey && PLAYER_CLASSES_LIST.includes(foundClassKey)) {
                        game.player.classe = foundClassKey;
                        const classeInfo = CLASSES_DATA[foundClassKey];
                        feedbackAlert = `Classe definida para ${classeInfo.nomeDisplay}!`;
                        game.player.magiasAdquiridas = []; game.player.magiasEquipadas = [];
                        if (foundClassKey === "Necromante") {
                            game.player.metLordeDaMorte = true;
                            feedbackAlert += "\nLorde da Morte 'encontrado'.";
                            ["n_extracao_sombras", "n_invocar_sombra"].forEach(skillId => {
                                const skillData = classeInfo.habilidades.find(h => h.id === skillId);
                                if (skillData && !game.player.magiasAdquiridas.includes(skillId)) {
                                    game.player.magiasAdquiridas.push(skillId); feedbackAlert += `\n- Aprendido: ${skillData.nome}.`;
                                    if (game.player.magiasEquipadas.length < 4) { game.player.magiasEquipadas.push(skillId); feedbackAlert += ` (Equipado)`; }
                                }
                            });
                        } else {
                            if (classeInfo.habilidades && classeInfo.habilidades.length > 0) {
                                const minUnlockLevel = Math.min(...classeInfo.habilidades.map(s => s.unlockLevel || 1));
                                classeInfo.habilidades.forEach(skill => {
                                    if ((skill.unlockLevel === minUnlockLevel || skill.unlockLevel === 1) && !game.player.magiasAdquiridas.includes(skill.id)) {
                                        game.player.magiasAdquiridas.push(skill.id); feedbackAlert += `\n- Aprendido: ${skill.nome}.`;
                                        if (game.player.magiasEquipadas.length < 4) { game.player.magiasEquipadas.push(skill.id); feedbackAlert += ` (Equipado)`; }
                                    }
                                });
                            }
                        }
                        alert(feedbackAlert);
                        atualizarAtributosDerivados(); atualizarStatusAtributos(); atualizarSkillsTela();
                        if (game.estado === 'inicio' && !game.batalha.emBatalha) abrirInicio();
                    } else {
                        alert(`Classe "${requestedClassNameInput}" inválida. Válidas: ${PLAYER_CLASSES_LIST.map(c => CLASSES_DATA[c]?.nomeDisplay || c).join(", ")}.`);
                    }

                } else if (commandTrimmed === "resetgameplz") {
                    if (confirm("Tem certeza que quer resetar TODO o progresso do jogo? Isso inclui o save na nuvem se estiver logado.")) {
                        deleteSavedGameForGoogleUser(); localStorage.clear();
                        alert("Jogo resetado. A página será recarregada."); location.reload();
                    }
                } else if (commandTrimmed === "addcoins") {
                    game.player.moedas += 1000; alert("1000 moedas adicionadas!"); atualizarStatusAtributos();
                } else if (commandTrimmed === "addxp") {
                    game.player.xp += 500; alert("500 XP adicionado!");
                    let leveledUpByXPCheat = false; let cheatLevelUpMessages = [];
                    while (game.player.xp >= game.player.xpProximoNivel) {
                        game.player.xp -= game.player.xpProximoNivel; game.player.nivel++; game.player.pontosDistribuir += 5;
                        for (const attr_key in game.player.atributos) game.player.atributos[attr_key] = +(game.player.atributos[attr_key] + 1).toFixed(1);
                        cheatLevelUpMessages.push(`Nível ${game.player.nivel}!`);
                        game.player.xpProximoNivel = Math.floor(game.player.xpProximoNivel * 1.30);
                        atualizarRank();
                        const skillUnlocks = verificarDesbloqueioHabilidadesClasse();
                        cheatLevelUpMessages = cheatLevelUpMessages.concat(skillUnlocks.map(s => s.replace(/<[^>]*>/g, "")));
                    }
                    if (leveledUpByXPCheat) {
                        alert("Você subiu de nível com o XP extra!\n" + cheatLevelUpMessages.join("\n"));
                        if (!game.player.classe && atribuirClasseAleatoriaSeNecessario()) { }
                    }
                    atualizarAtributosDerivados(); atualizarStatusAtributos(); atualizarSkillsTela();
                } else {
                    alert(`Comando desconhecido: "${commandTrimmed}"`);
                }
                if (inputField) inputField.value = "";
            }


            document.getElementById("btn-inicio")?.addEventListener("click", abrirInicio);
            document.getElementById("btn-atributos")?.addEventListener("click", abrirAtributos);
            document.getElementById("btn-skills")?.addEventListener("click", abrirSkills);
            document.getElementById("btn-inventario")?.addEventListener("click", abrirInventario);
            document.getElementById("btn-mercador")?.addEventListener("click", abrirMercador);
            document.getElementById("btn-sair")?.addEventListener("click", sairJogo);

            document.getElementById("atributos-screen")?.addEventListener("click", manipularBotaoAtributo);
            document.getElementById("btn-salvar-atributos")?.addEventListener("click", salvarAtributos);
            document.getElementById("btn-comprar-mercador")?.addEventListener("click", comprarItensMercador);

            const btnSendCommand = document.getElementById("btn-send-command");
            if (btnSendCommand) {
                btnSendCommand.addEventListener("click", () => {
                    const commandInput = document.getElementById("chat-command-input");
                    if (commandInput && commandInput.value) processChatCommand(commandInput.value);
                });
            }
            const chatCommandInput = document.getElementById("chat-command-input");
            if (chatCommandInput) {
                chatCommandInput.addEventListener("keypress", (event) => {
                    if (event.key === "Enter") {
                        if (chatCommandInput.value) { processChatCommand(chatCommandInput.value); event.preventDefault(); }
                    }
                });
            }

            function sairJogo() {
                if (confirm("Deseja realmente sair do jogo? O progresso não salvo na nuvem (Google) pode ser perdido se você não usou o botão 'Salvar Progresso'. Progresso local não salvo com o Google não persistirá.")) {
                    location.reload();
                }
            }

        })();

    </script>
</body>

</html>
